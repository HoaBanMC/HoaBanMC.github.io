/* (c) Mathigon, generated by Mathigon Studio */
(() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __decorate = (decorators, target, key, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key, result) : decorator(result)) || result;
    if (kind && result)
      __defProp(target, key, result);
    return result;
  };
  var __async = (__this, __arguments, generator) => {
    return new Promise((resolve, reject) => {
      var fulfilled = (value) => {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      };
      var rejected = (value) => {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      };
      var step = (result) => {
        return result.done ? resolve(result.value) : Promise.resolve(result.value).then(fulfilled, rejected);
      };
      step((generator = generator.apply(__this, __arguments)).next());
    });
  };

  // node_modules/@mathigon/core/dist/core.esm.js
  function uid(n = 10) {
    return Math.random().toString(36).substr(2, n);
  }
  function isOneOf(x, ...values) {
    return values.includes(x);
  }
  function applyDefaults(obj = {}, defaults) {
    for (const key of Object.keys(defaults)) {
      if (!Object.prototype.hasOwnProperty.call(obj, key))
        obj[key] = defaults[key];
    }
    return obj;
  }
  var defaultMerge = (a2, b2) => a2.concat(b2);
  function deepExtend(obj1, obj2, arrayMergeFn = defaultMerge) {
    for (const i of Object.keys(obj2)) {
      if (i in obj1 && Array.isArray(obj1[i]) && Array.isArray(obj2[i])) {
        obj1[i] = arrayMergeFn(obj1[i], obj2[i]);
      } else if (i in obj1 && obj1[i] instanceof Object && obj2[i] instanceof Object) {
        deepExtend(obj1[i], obj2[i]);
      } else {
        obj1[i] = obj2[i];
      }
    }
  }
  function delay(fn, t = 0) {
    if (t) {
      return +setTimeout(fn, t);
    } else {
      fn();
      return 0;
    }
  }
  function defer() {
    let resolve = () => void 0;
    let reject = () => void 0;
    const promise = new Promise((_resolve, _reject) => {
      resolve = _resolve;
      reject = _reject;
    });
    promise.catch((error) => error);
    return {promise, resolve, reject};
  }
  function throttle(fn, t = 0, forceDelay = false) {
    let delay2 = false;
    let repeat2 = false;
    return (...args) => {
      if (delay2) {
        repeat2 = true;
      } else {
        if (forceDelay) {
          repeat2 = true;
        } else {
          fn(...args);
        }
        delay2 = true;
        setTimeout(() => {
          if (repeat2)
            fn(...args);
          delay2 = repeat2 = false;
        }, t);
      }
    };
  }
  function safeToJSON(str, fallback = {}) {
    if (!str)
      return fallback;
    try {
      return JSON.parse(str) || fallback;
    } catch (e) {
      return fallback;
    }
  }
  function repeat(value, n) {
    return new Array(n).fill(value);
  }
  function tabulate(fn, n) {
    const result = [];
    for (let i = 0; i < n; ++i) {
      result.push(fn(i));
    }
    return result;
  }
  function last(array, i = 0) {
    return array[array.length - 1 - i];
  }
  function total(array) {
    return array.reduce((t, v) => t + v, 0);
  }
  function unique(array) {
    return array.filter((a2, i) => array.indexOf(a2) === i);
  }
  function flatten(array) {
    return array.reduce((a2, b2) => a2.concat(Array.isArray(b2) ? flatten(b2) : b2), []);
  }
  function chunk(array, n) {
    const chunks = [];
    for (let i = 0; i < array.length; i += n) {
      chunks.push(array.slice(i, i + n));
    }
    return chunks;
  }
  function words(str, divider = /\s+/) {
    if (!str)
      return [];
    return str.trim().split(divider);
  }
  function toCamelCase(str) {
    return str.toLowerCase().replace(/^-/, "").replace(/-(.)/g, (_, g) => g.toUpperCase());
  }
  var EventTarget = class {
    constructor() {
      this.events = new Map();
    }
    on(events, fn) {
      for (const e of words(events)) {
        if (!this.events.has(e))
          this.events.set(e, []);
        this.events.get(e).push(fn);
      }
    }
    one(events, fn) {
      const callback = (e) => {
        this.off(events, callback);
        fn(e);
      };
      this.on(events, callback);
    }
    off(events, fn) {
      for (const e of words(events)) {
        if (this.events.has(e)) {
          this.events.set(e, this.events.get(e).filter((x) => x !== fn));
        }
      }
    }
    trigger(events, arg) {
      for (const e of words(events)) {
        if (this.events.has(e)) {
          for (const callback of this.events.get(e)) {
            callback(arg);
          }
        }
      }
    }
  };
  var Itarray = class {
    constructor(...values) {
      this.values = values;
    }
    map(fn) {
      const values = this.values;
      return new Itarray(function* () {
        let i = 0;
        for (const row of values) {
          for (const v of row) {
            yield fn(v, i);
            i += 1;
          }
        }
      }());
    }
    every(fn) {
      let i = 0;
      for (const row of this.values) {
        for (const v of row) {
          if (!fn(v, i))
            return false;
          i += 1;
        }
      }
      return true;
    }
    some(fn) {
      let i = 0;
      for (const row of this.values) {
        for (const v of row) {
          if (fn(v, i))
            return true;
          i += 1;
        }
      }
      return false;
    }
    slice(from, to) {
      const values = this.values;
      return new Itarray(function* () {
        let i = 0;
        for (const row of values) {
          for (const v of row) {
            if (i < from || to !== void 0 && i > from + to)
              continue;
            yield v;
            i += 1;
          }
        }
      }());
    }
    filter(fn) {
      const values = this.values;
      return new Itarray(function* () {
        let i = 0;
        for (const row of values) {
          for (const v of row) {
            if (fn(v, i))
              yield v;
            i += 1;
          }
        }
      }());
    }
    concat(newValues) {
      this.values.push(newValues);
    }
    [Symbol.iterator]() {
      const values = this.values;
      return function* () {
        for (const row of values) {
          for (const v of row) {
            yield v;
          }
        }
      }();
    }
    static make(fn, max) {
      return new Itarray(function* () {
        let i = 0;
        while (max === void 0 || i < max) {
          yield fn(i);
          i += 1;
        }
      }());
    }
  };

  // node_modules/@mathigon/fermat/dist/fermat.esm.js
  var PRECISION = 1e-6;
  function nearlyEquals(x, y, t = PRECISION) {
    if (isNaN(x) || isNaN(y))
      return false;
    return Math.abs(x - y) < t;
  }
  function isBetween(x, a2, b2, t = PRECISION) {
    if (a2 > b2)
      [a2, b2] = [b2, a2];
    return x > a2 + t && x < b2 - t;
  }
  function roundTo(n, increment = 1) {
    return Math.round(n / increment) * increment;
  }
  function clamp(x, min = -Infinity, max = Infinity) {
    return Math.min(max, Math.max(min, x));
  }
  function lerp(a2, b2, t = 0.5) {
    return a2 + (b2 - a2) * t;
  }
  function square(x) {
    return x * x;
  }
  function mod(a2, m) {
    return (a2 % m + m) % m;
  }
  function subsets(array, length = 0) {
    const copy = array.slice(0);
    const results = subsetsHelper(copy);
    return length ? results.filter((x) => x.length === length) : results;
  }
  function subsetsHelper(array) {
    if (array.length === 1)
      return [[], array];
    const last2 = array.pop();
    const subsets2 = subsetsHelper(array);
    const result = [];
    for (const s of subsets2) {
      result.push(s, [...s, last2]);
    }
    return result;
  }
  function shuffle(a2) {
    a2 = a2.slice(0);
    for (let i = a2.length - 1; i > 0; --i) {
      const j = Math.floor(Math.random() * (i + 1));
      [a2[i], a2[j]] = [a2[j], a2[i]];
    }
    return a2;
  }
  function integer(a2, b2) {
    const start = b2 === void 0 ? 0 : a2;
    const length = b2 === void 0 ? a2 : b2 - a2 + 1;
    return start + Math.floor(length * Math.random());
  }
  function weighted(weights) {
    const x = Math.random() * total(weights);
    let cum = 0;
    return weights.findIndex((w) => (cum += w) >= x);
  }
  function find(items) {
    return items[Math.floor(items.length * Math.random())];
  }
  var SMART_RANDOM_CACHE = new Map();
  function smart(n, id) {
    if (!id)
      id = uid();
    if (!SMART_RANDOM_CACHE.has(id))
      SMART_RANDOM_CACHE.set(id, repeat(1, n));
    const cache = SMART_RANDOM_CACHE.get(id);
    const x = weighted(cache.map((x2) => x2 * x2));
    cache[x] -= 1;
    if (cache[x] <= 0)
      SMART_RANDOM_CACHE.set(id, cache.map((x2) => x2 + 1));
    return x;
  }
  function bernoulli(p = 0.5) {
    return Math.random() < p ? 1 : 0;
  }
  function binomial$1(n = 1, p = 0.5) {
    let t = 0;
    for (let i = 0; i < n; ++i)
      t += bernoulli(p);
    return t;
  }
  function poisson(l = 1) {
    if (l <= 0)
      return 0;
    const L = Math.exp(-l);
    let p = 1;
    let k = 0;
    for (; p > L; ++k)
      p *= Math.random();
    return k - 1;
  }
  function uniform(a2 = 0, b2 = 1) {
    return a2 + (b2 - a2) * Math.random();
  }
  function normal(m = 0, v = 1) {
    const u1 = Math.random();
    const u2 = Math.random();
    const rand = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
    return rand * Math.sqrt(v) + m;
  }
  function exponential(l = 1) {
    return l <= 0 ? 0 : -Math.log(Math.random()) / l;
  }
  function geometric(p = 0.5) {
    if (p <= 0 || p > 1)
      return void 0;
    return Math.floor(Math.log(Math.random()) / Math.log(1 - p));
  }
  function cauchy() {
    let rr;
    let v1;
    let v2;
    do {
      v1 = 2 * Math.random() - 1;
      v2 = 2 * Math.random() - 1;
      rr = v1 * v1 + v2 * v2;
    } while (rr >= 1);
    return v1 / v2;
  }
  function normalPDF(x, m = 1, v = 0) {
    return Math.exp(-((x - m) ** 2) / (2 * v)) / Math.sqrt(2 * Math.PI * v);
  }
  var G = 7;
  var P = [
    0.9999999999998099,
    676.5203681218851,
    -1259.1392167224028,
    771.3234287776531,
    -176.6150291621406,
    12.507343278686905,
    -0.13857109526572012,
    9984369578019572e-21,
    15056327351493116e-23
  ];
  function gamma(z) {
    if (z < 0.5)
      return Math.PI / (Math.sin(Math.PI * z) * gamma(1 - z));
    z -= 1;
    let x = P[0];
    for (let i = 1; i < G + 2; i++)
      x += P[i] / (z + i);
    const t = z + G + 0.5;
    return Math.sqrt(2 * Math.PI) * Math.pow(t, z + 0.5) * Math.exp(-t) * x;
  }
  function integrate(fn, xMin, xMax, dx = 1) {
    let result = 0;
    for (let x = xMin; x < xMax; x += dx) {
      result += fn(x) * dx || 0;
    }
    return result;
  }
  function chiCDF(chi, deg) {
    const int = integrate((t) => Math.pow(t, (deg - 2) / 2) * Math.exp(-t / 2), 0, chi);
    return 1 - int / Math.pow(2, deg / 2) / gamma(deg / 2);
  }
  var random = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    shuffle,
    integer,
    weighted,
    find,
    smart,
    bernoulli,
    binomial: binomial$1,
    poisson,
    uniform,
    normal,
    exponential,
    geometric,
    cauchy,
    normalPDF,
    integrate,
    chiCDF
  });

  // node_modules/@mathigon/euclid/dist/euclid.esm.js
  var TWO_PI = 2 * Math.PI;
  function rad(p, c) {
    const a2 = Math.atan2(p.y - (c ? c.y : 0), p.x - (c ? c.x : 0));
    return mod(a2, TWO_PI);
  }
  var Point = class {
    constructor(x = 0, y = 0) {
      this.x = x;
      this.y = y;
      this.type = "point";
    }
    get unitVector() {
      if (nearlyEquals(this.length, 0))
        return new Point(1, 0);
      return this.scale(1 / this.length);
    }
    get length() {
      return Math.sqrt(this.x ** 2 + this.y ** 2);
    }
    get inverse() {
      return new Point(-this.x, -this.y);
    }
    get flip() {
      return new Point(this.y, this.x);
    }
    get perpendicular() {
      return new Point(-this.y, this.x);
    }
    get array() {
      return [this.x, this.y];
    }
    distanceFromLine(l) {
      return Point.distance(this, l.project(this));
    }
    clamp(bounds, padding = 0) {
      const x = clamp(this.x, bounds.xMin + padding, bounds.xMax - padding);
      const y = clamp(this.y, bounds.yMin + padding, bounds.yMax - padding);
      return new Point(x, y);
    }
    changeCoordinates(originCoords, targetCoords) {
      const x = targetCoords.xMin + (this.x - originCoords.xMin) / originCoords.dx * targetCoords.dx;
      const y = targetCoords.yMin + (this.y - originCoords.yMin) / originCoords.dy * targetCoords.dy;
      return new Point(x, y);
    }
    add(p) {
      return Point.sum(this, p);
    }
    subtract(p) {
      return Point.difference(this, p);
    }
    round(inc = 1) {
      return new Point(roundTo(this.x, inc), roundTo(this.y, inc));
    }
    floor() {
      return new Point(Math.floor(this.x), Math.floor(this.y));
    }
    mod(x, y = x) {
      return new Point(this.x % x, this.y % y);
    }
    angle(c = ORIGIN) {
      return rad(this, c);
    }
    snap(p, tolerance = 5) {
      if (nearlyEquals(this.x, p.x, tolerance))
        return new Point(p.x, this.y);
      if (nearlyEquals(this.y, p.y, tolerance))
        return new Point(this.x, p.y);
      return this;
    }
    static average(...points) {
      const x = total(points.map((p) => p.x)) / points.length;
      const y = total(points.map((p) => p.y)) / points.length;
      return new Point(x, y);
    }
    static dot(p1, p2) {
      return p1.x * p2.x + p1.y * p2.y;
    }
    static sum(p1, p2) {
      return new Point(p1.x + p2.x, p1.y + p2.y);
    }
    static difference(p1, p2) {
      return new Point(p1.x - p2.x, p1.y - p2.y);
    }
    static distance(p1, p2) {
      return Math.sqrt(square(p1.x - p2.x) + square(p1.y - p2.y));
    }
    static manhattan(p1, p2) {
      return Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y);
    }
    static interpolate(p1, p2, t = 0.5) {
      return new Point(lerp(p1.x, p2.x, t), lerp(p1.y, p2.y, t));
    }
    static interpolateList(points, t = 0.5) {
      const n = points.length - 1;
      const a2 = Math.floor(clamp(t, 0, 1) * n);
      return Point.interpolate(points[a2], points[a2 + 1], n * t - a2);
    }
    static fromPolar(angle, r = 1) {
      return new Point(r * Math.cos(angle), r * Math.sin(angle));
    }
    static random(b2) {
      const x = random.uniform(b2.xMin, b2.xMax);
      const y = random.uniform(b2.yMin, b2.yMax);
      return new Point(x, y);
    }
    transform(m) {
      const x = m[0][0] * this.x + m[0][1] * this.y + m[0][2];
      const y = m[1][0] * this.x + m[1][1] * this.y + m[1][2];
      return new Point(x, y);
    }
    rotate(angle, c = ORIGIN) {
      if (nearlyEquals(angle, 0))
        return this;
      const x0 = this.x - c.x;
      const y0 = this.y - c.y;
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);
      const x = x0 * cos - y0 * sin + c.x;
      const y = x0 * sin + y0 * cos + c.y;
      return new Point(x, y);
    }
    reflect(l) {
      const v = l.p2.x - l.p1.x;
      const w = l.p2.y - l.p1.y;
      const x0 = this.x - l.p1.x;
      const y0 = this.y - l.p1.y;
      const mu = (v * y0 - w * x0) / (v * v + w * w);
      const x = this.x + 2 * mu * w;
      const y = this.y - 2 * mu * v;
      return new Point(x, y);
    }
    scale(sx, sy = sx) {
      return new Point(this.x * sx, this.y * sy);
    }
    shift(x, y = x) {
      return new Point(this.x + x, this.y + y);
    }
    translate(p) {
      return this.shift(p.x, p.y);
    }
    equals(other, precision) {
      return nearlyEquals(this.x, other.x, precision) && nearlyEquals(this.y, other.y, precision);
    }
  };
  var ORIGIN = new Point(0, 0);
  var Line = class {
    constructor(p1, p2) {
      this.p1 = p1;
      this.p2 = p2;
      this.type = "line";
    }
    make(p1, p2) {
      return new Line(p1, p2);
    }
    get length() {
      return Point.distance(this.p1, this.p2);
    }
    get lengthSquared() {
      return (this.p1.x - this.p2.x) ** 2 + (this.p1.y - this.p2.y) ** 2;
    }
    get midpoint() {
      return Point.average(this.p1, this.p2);
    }
    get slope() {
      return (this.p2.y - this.p1.y) / (this.p2.x - this.p1.x);
    }
    get intercept() {
      return this.p1.y + this.slope * this.p1.x;
    }
    get angle() {
      return rad(this.p2, this.p1);
    }
    get unitVector() {
      return this.p2.subtract(this.p1).unitVector;
    }
    get perpendicularVector() {
      return new Point(this.p2.y - this.p1.y, this.p1.x - this.p2.x).unitVector;
    }
    parallel(p) {
      const q = Point.sum(p, Point.difference(this.p2, this.p1));
      return new Line(p, q);
    }
    perpendicular(p) {
      return new Line(p, Point.sum(p, this.perpendicularVector));
    }
    get perpendicularBisector() {
      return this.perpendicular(this.midpoint);
    }
    distanceSquared(p) {
      const proj = this.project(p);
      return (p.x - proj.x) ** 2 + (p.y - proj.y) ** 2;
    }
    offset(p) {
      const a2 = Point.difference(this.p2, this.p1);
      const b2 = Point.difference(p, this.p1);
      return Point.dot(a2, b2) / this.lengthSquared;
    }
    project(p) {
      return this.at(this.offset(p));
    }
    side(p, tolerance) {
      const a2 = Point.difference(this.p2, this.p1);
      const b2 = Point.difference(p, this.p1);
      const d = b2.x * a2.y - b2.y * a2.x;
      return nearlyEquals(d, 0, tolerance) ? 0 : Math.sign(d);
    }
    contains(p, tolerance) {
      return this.side(p, tolerance) === 0;
    }
    at(t) {
      return Point.interpolate(this.p1, this.p2, t);
    }
    transform(m) {
      return new this.constructor(this.p1.transform(m), this.p2.transform(m));
    }
    rotate(a2, c = ORIGIN) {
      if (nearlyEquals(a2, 0))
        return this;
      return new this.constructor(this.p1.rotate(a2, c), this.p2.rotate(a2, c));
    }
    reflect(l) {
      return new this.constructor(this.p1.reflect(l), this.p2.reflect(l));
    }
    scale(sx, sy = sx) {
      return this.make(this.p1.scale(sx, sy), this.p2.scale(sx, sy));
    }
    shift(x, y = x) {
      return this.make(this.p1.shift(x, y), this.p2.shift(x, y));
    }
    translate(p) {
      return this.shift(p.x, p.y);
    }
    equals(other, tolerance) {
      return this.contains(other.p1, tolerance) && this.contains(other.p2, tolerance);
    }
  };
  var Segment = class extends Line {
    constructor() {
      super(...arguments);
      this.type = "segment";
    }
    contains(p, tolerance) {
      if (!Line.prototype.contains.call(this, p, tolerance))
        return false;
      if (this.p1.equals(p, tolerance) || this.p2.equals(p, tolerance))
        return true;
      if (nearlyEquals(this.p1.x, this.p2.x, tolerance)) {
        return isBetween(p.y, this.p1.y, this.p2.y);
      } else {
        return isBetween(p.x, this.p1.x, this.p2.x);
      }
    }
    make(p1, p2) {
      return new Segment(p1, p2);
    }
    project(p) {
      const a2 = Point.difference(this.p2, this.p1);
      const b2 = Point.difference(p, this.p1);
      const q = clamp(Point.dot(a2, b2) / this.lengthSquared, 0, 1);
      return Point.sum(this.p1, a2.scale(q));
    }
    contract(x) {
      return new Segment(this.at(x), this.at(1 - x));
    }
    equals(other, tolerance, oriented = false) {
      if (other.type !== "segment")
        return false;
      return this.p1.equals(other.p1, tolerance) && this.p2.equals(other.p2, tolerance) || !oriented && this.p1.equals(other.p2, tolerance) && this.p2.equals(other.p1, tolerance);
    }
  };
  var RAD_TO_DEG = 180 / Math.PI;
  var DEG_TO_RAD = Math.PI / 180;
  function isPolygonLike(shape) {
    return ["polygon", "polyline", "rectangle", "triangle"].includes(shape.type);
  }
  function isPolygon(shape) {
    return ["polygon", "triangle"].includes(shape.type);
  }
  function isPolyline(shape) {
    return shape.type === "polyline";
  }
  function isRectangle(shape) {
    return shape.type === "rectangle";
  }
  function isLineLike(shape) {
    return ["line", "ray", "segment"].includes(shape.type);
  }
  function isLine(shape) {
    return shape.type === "line";
  }
  function isRay(shape) {
    return shape.type === "ray";
  }
  function isSegment(shape) {
    return shape.type === "segment";
  }
  function isCircle(shape) {
    return shape.type === "circle";
  }
  function isArc(shape) {
    return shape.type === "arc";
  }
  function isSector(shape) {
    return shape.type === "sector";
  }
  function isAngle(shape) {
    return shape.type === "angle";
  }
  function liesOnSegment(s, p) {
    if (nearlyEquals(s.p1.x, s.p2.x))
      return isBetween(p.y, s.p1.y, s.p2.y);
    return isBetween(p.x, s.p1.x, s.p2.x);
  }
  function liesOnRay(r, p) {
    if (nearlyEquals(r.p1.x, r.p2.x)) {
      return (p.y - r.p1.y) / (r.p2.y - r.p1.y) > 0;
    }
    return (p.x - r.p1.x) / (r.p2.x - r.p1.x) > 0;
  }
  function lineLineIntersection(l1, l2) {
    const d1x = l1.p1.x - l1.p2.x;
    const d1y = l1.p1.y - l1.p2.y;
    const d2x = l2.p1.x - l2.p2.x;
    const d2y = l2.p1.y - l2.p2.y;
    const d = d1x * d2y - d1y * d2x;
    if (nearlyEquals(d, 0))
      return [];
    const q1 = l1.p1.x * l1.p2.y - l1.p1.y * l1.p2.x;
    const q2 = l2.p1.x * l2.p2.y - l2.p1.y * l2.p2.x;
    const x = q1 * d2x - d1x * q2;
    const y = q1 * d2y - d1y * q2;
    return [new Point(x / d, y / d)];
  }
  function circleCircleIntersection(c1, c2) {
    const d = Point.distance(c1.c, c2.c);
    if (d > c1.r + c2.r)
      return [];
    if (d < Math.abs(c1.r - c2.r))
      return [];
    if (nearlyEquals(d, 0) && nearlyEquals(c1.r, c2.r))
      return [];
    if (nearlyEquals(d, c1.r + c2.r))
      return [new Line(c1.c, c2.c).midpoint];
    const a2 = (square(c1.r) - square(c2.r) + square(d)) / (2 * d);
    const b2 = Math.sqrt(square(c1.r) - square(a2));
    const px = (c2.c.x - c1.c.x) * a2 / d + (c2.c.y - c1.c.y) * b2 / d + c1.c.x;
    const py = (c2.c.y - c1.c.y) * a2 / d - (c2.c.x - c1.c.x) * b2 / d + c1.c.y;
    const qx = (c2.c.x - c1.c.x) * a2 / d - (c2.c.y - c1.c.y) * b2 / d + c1.c.x;
    const qy = (c2.c.y - c1.c.y) * a2 / d + (c2.c.x - c1.c.x) * b2 / d + c1.c.y;
    return [new Point(px, py), new Point(qx, qy)];
  }
  function lineCircleIntersection(l, c) {
    const dx = l.p2.x - l.p1.x;
    const dy = l.p2.y - l.p1.y;
    const dr2 = square(dx) + square(dy);
    const cx = c.c.x;
    const cy = c.c.y;
    const D = (l.p1.x - cx) * (l.p2.y - cy) - (l.p2.x - cx) * (l.p1.y - cy);
    const disc = square(c.r) * dr2 - square(D);
    if (disc < 0)
      return [];
    const xa = D * dy / dr2;
    const ya = -D * dx / dr2;
    if (nearlyEquals(disc, 0))
      return [c.c.shift(xa, ya)];
    const xb = dx * (dy < 0 ? -1 : 1) * Math.sqrt(disc) / dr2;
    const yb = Math.abs(dy) * Math.sqrt(disc) / dr2;
    return [c.c.shift(xa + xb, ya + yb), c.c.shift(xa - xb, ya - yb)];
  }
  function simpleIntersection(a2, b2) {
    let results = [];
    if (isLineLike(a2) && isLineLike(b2)) {
      results = lineLineIntersection(a2, b2);
    } else if (isLineLike(a2) && isCircle(b2)) {
      results = lineCircleIntersection(a2, b2);
    } else if (isCircle(a2) && isLineLike(b2)) {
      results = lineCircleIntersection(b2, a2);
    } else if (isCircle(a2) && isCircle(b2)) {
      results = circleCircleIntersection(a2, b2);
    }
    for (const x of [a2, b2]) {
      if (x.type === "segment") {
        results = results.filter((i) => liesOnSegment(x, i));
      }
      if (x.type === "ray")
        results = results.filter((i) => liesOnRay(x, i));
    }
    return results;
  }
  function intersections(...elements) {
    if (elements.length < 2)
      return [];
    if (elements.length > 2) {
      return flatten(subsets(elements, 2).map((e) => intersections(...e)));
    }
    let [a2, b2] = elements;
    if (isPolygonLike(b2))
      [a2, b2] = [b2, a2];
    if (isPolygonLike(a2)) {
      const results = isLineLike(b2) ? a2.points.filter((p) => b2.contains(p)) : [];
      for (const e of a2.edges)
        results.push(...intersections(e, b2));
      return results;
    }
    return simpleIntersection(a2, b2);
  }
  var Polygon = class {
    constructor(...points) {
      this.type = "polygon";
      this.points = points;
    }
    get circumference() {
      if (this.points.length <= 1)
        return 0;
      let length = Point.distance(this.points[0], last(this.points));
      for (let i = 1; i < this.points.length; ++i) {
        length += Point.distance(this.points[i - 1], this.points[i]);
      }
      return length;
    }
    get signedArea() {
      const p = this.points;
      const n = p.length;
      let A = p[n - 1].x * p[0].y - p[0].x * p[n - 1].y;
      for (let i = 1; i < n; ++i) {
        A += p[i - 1].x * p[i].y - p[i].x * p[i - 1].y;
      }
      return A / 2;
    }
    get area() {
      return Math.abs(this.signedArea);
    }
    get centroid() {
      const p = this.points;
      const n = p.length;
      let Cx = 0;
      for (let i = 0; i < n; ++i)
        Cx += p[i].x;
      let Cy = 0;
      for (let i = 0; i < n; ++i)
        Cy += p[i].y;
      return new Point(Cx / n, Cy / n);
    }
    get edges() {
      const p = this.points;
      const n = p.length;
      const edges = [];
      for (let i = 0; i < n; ++i)
        edges.push(new Segment(p[i], p[(i + 1) % n]));
      return edges;
    }
    get radius() {
      const c = this.centroid;
      const radii = this.points.map((p) => Point.distance(p, c));
      return Math.max(...radii);
    }
    get oriented() {
      if (this.signedArea >= 0)
        return this;
      const points = [...this.points].reverse();
      return new this.constructor(...points);
    }
    cut(line) {
      let edges = [];
      const edgesOnLine = [];
      for (const e of this.edges) {
        const side1 = line.side(e.p1);
        const side2 = line.side(e.p2);
        if (side1 && side2 && side1 !== side2) {
          const int = intersections(e, line)[0];
          edges.push(new Segment(e.p1, int));
          const e2 = new Segment(int, e.p2);
          e2.flag = side2;
          edges.push(e2);
          edgesOnLine.push(e2);
        } else {
          if (side1 === 0 && side2) {
            edgesOnLine.push(e);
            e.flag = side2;
          }
          edges.push(e);
        }
      }
      if (edgesOnLine.length < 2)
        return [this];
      edgesOnLine.sort((u, v) => line.offset(u.p1) - line.offset(v.p1));
      const getEdges = (i0, i1) => {
        const n = edges.length;
        const results2 = [];
        if (i1 < i0)
          i1 += n;
        for (let i = i0; i <= i1; i++)
          results2.push(edges[i % n]);
        return results2;
      };
      const traverseEdges = (i0) => {
        const n = edges.length;
        const startFlag = edges[i0].flag;
        let i = i0;
        while (true) {
          i = (i + 1) % n;
          if (edges[i].flag === startFlag) {
            edges[i].flag = void 0;
            edgesOnLine.splice(edgesOnLine.indexOf(edges[i]), 1);
          }
          if (i === i0 || edges[i].flag)
            return i;
        }
      };
      const results = [];
      let dir = 0;
      while (edgesOnLine.length >= 2) {
        let e0 = edgesOnLine[0];
        let e1 = edgesOnLine[1];
        let i0 = edges.indexOf(e0);
        let i1 = edges.indexOf(e1);
        let solved = false;
        if (traverseEdges(i0) === i1) {
          solved = true;
        } else {
          [e0, e1] = [e1, e0];
          [i0, i1] = [i1, i0];
          if (traverseEdges(i0) === i1)
            solved = true;
        }
        if (solved) {
          dir--;
          results.push(getEdges(i0, i1));
          edges = getEdges(i1, i0);
          e0.flag = e1.flag = void 0;
          edgesOnLine.splice(0, 2);
          if (edgesOnLine.length < 2)
            results.push(edges);
        } else {
          dir++;
          edgesOnLine.reverse();
        }
        if (dir > 1)
          break;
      }
      return results.map((r) => new Polygon(...r.map((e) => e.p1)));
    }
    static collision(p1, p2) {
      if (p1.points.some((q) => p2.contains(q)))
        return true;
      if (p2.points.some((q) => p1.contains(q)))
        return true;
      for (const e1 of p1.edges) {
        for (const e2 of p2.edges) {
          if (intersections(e1, e2)[0])
            return true;
        }
      }
      return false;
    }
    static regular(n, radius = 1) {
      const da = TWO_PI / n;
      const a0 = Math.PI / 2 - da / 2;
      const points = tabulate((i) => Point.fromPolar(a0 + da * i, radius), n);
      return new Polygon(...points);
    }
    static interpolate(p1, p2, t = 0.5) {
      const points = p1.points.map((p, i) => Point.interpolate(p, p2.points[i], t));
      return new Polygon(...points);
    }
    contains(p) {
      let inside = false;
      for (const e of this.edges) {
        if (e.p1.equals(p) || e.contains(p))
          return false;
        if (e.p1.y > p.y === e.p2.y > p.y)
          continue;
        const det = (e.p2.x - e.p1.x) / (e.p2.y - e.p1.y);
        if (p.x < det * (p.y - e.p1.y) + e.p1.x)
          inside = !inside;
      }
      return inside;
    }
    at(t) {
      return Point.interpolateList([...this.points, this.points[0]], t);
    }
    project(p) {
      let q = void 0;
      let d = Infinity;
      for (const e of this.edges) {
        const q1 = e.project(p);
        const d1 = Point.distance(p, q1);
        if (d1 < d) {
          q = q1;
          d = d1;
        }
      }
      return q || this.points[0];
    }
    transform(m) {
      return new this.constructor(...this.points.map((p) => p.transform(m)));
    }
    rotate(a2, center = ORIGIN) {
      if (nearlyEquals(a2, 0))
        return this;
      const points = this.points.map((p) => p.rotate(a2, center));
      return new this.constructor(...points);
    }
    reflect(line) {
      const points = this.points.map((p) => p.reflect(line));
      return new this.constructor(...points);
    }
    scale(sx, sy = sx) {
      const points = this.points.map((p) => p.scale(sx, sy));
      return new this.constructor(...points);
    }
    shift(x, y = x) {
      const points = this.points.map((p) => p.shift(x, y));
      return new this.constructor(...points);
    }
    translate(p) {
      return this.shift(p.x, p.y);
    }
    equals(_other) {
      return false;
    }
  };
  var Rectangle = class {
    constructor(p, w = 1, h = w) {
      this.p = p;
      this.w = w;
      this.h = h;
      this.type = "rectangle";
    }
    static aroundPoints(points) {
      let xMin = Infinity;
      let xMax = -Infinity;
      let yMin = Infinity;
      let yMax = -Infinity;
      for (const p of points) {
        xMin = xMin < p.x ? xMin : p.x;
        xMax = xMax > p.x ? xMax : p.x;
        yMin = yMin < p.y ? yMin : p.y;
        yMax = yMax > p.y ? yMax : p.y;
      }
      return new Rectangle(new Point(xMin, yMin), xMax - xMin, yMax - yMin);
    }
    get center() {
      return new Point(this.p.x + this.w / 2, this.p.y + this.h / 2);
    }
    get centroid() {
      return this.center;
    }
    get circumference() {
      return 2 * Math.abs(this.w) + 2 * Math.abs(this.h);
    }
    get area() {
      return Math.abs(this.w * this.h);
    }
    get edges() {
      return this.polygon.edges;
    }
    get points() {
      return this.polygon.points;
    }
    get polygon() {
      const b2 = new Point(this.p.x + this.w, this.p.y);
      const c = new Point(this.p.x + this.w, this.p.y + this.h);
      const d = new Point(this.p.x, this.p.y + this.h);
      return new Polygon(this.p, b2, c, d);
    }
    collision(r) {
      return this.p.x < r.p.x + r.w && this.p.x + this.w > r.p.x && this.p.y < r.p.y + r.h && this.p.y + this.h > r.p.y;
    }
    contains(p, tolerance) {
      return isBetween(p.x, this.p.x, this.p.x + this.w, tolerance) && isBetween(p.y, this.p.y, this.p.y + this.h, tolerance);
    }
    project(p) {
      let q = void 0;
      for (const e of this.edges) {
        const q1 = e.project(p);
        if (!q || Point.distance(p, q1) < Point.distance(p, q))
          q = q1;
      }
      return q;
    }
    at(_t) {
      return this.p;
    }
    transform(m) {
      return this.polygon.transform(m);
    }
    rotate(a2, c = ORIGIN) {
      if (nearlyEquals(a2, 0))
        return this;
      return this.polygon.rotate(a2, c);
    }
    reflect(l) {
      return this.polygon.reflect(l);
    }
    scale(sx, sy = sx) {
      return new Rectangle(this.p.scale(sx, sy), this.w * sx, this.h * sy);
    }
    shift(x, y = x) {
      return new Rectangle(this.p.shift(x, y), this.w, this.h);
    }
    translate(p) {
      return this.shift(p.x, p.y);
    }
    equals(_other) {
      return false;
    }
  };
  function drawCanvas(ctx, obj, options = {}) {
    if (options.fill)
      ctx.fillStyle = options.fill;
    if (options.opacity)
      ctx.globalAlpha = options.opacity;
    if (options.stroke) {
      ctx.strokeStyle = options.stroke;
      ctx.lineWidth = options.strokeWidth || 1;
      if (options.lineCap)
        ctx.lineCap = options.lineCap;
      if (options.lineJoin)
        ctx.lineJoin = options.lineJoin;
    }
    ctx.beginPath();
    if (isSegment(obj)) {
      ctx.moveTo(obj.p1.x, obj.p1.y);
      ctx.lineTo(obj.p2.x, obj.p2.y);
    } else if (isCircle(obj)) {
      ctx.arc(obj.c.x, obj.c.y, obj.r, 0, TWO_PI);
    } else if (isPolygon(obj)) {
      ctx.moveTo(obj.points[0].x, obj.points[0].y);
      for (const p of obj.points.slice(1))
        ctx.lineTo(p.x, p.y);
      ctx.closePath();
    } else if (isPolyline(obj)) {
      ctx.moveTo(obj.points[0].x, obj.points[0].y);
      for (const p of obj.points.slice(1))
        ctx.lineTo(p.x, p.y);
    }
    if (options.fill)
      ctx.fill();
    if (options.stroke)
      ctx.stroke();
  }
  function drawArc(a2, b2, c) {
    const orient = b2.x * (c.y - a2.y) + a2.x * (b2.y - c.y) + c.x * (a2.y - b2.y);
    const sweep = orient > 0 ? 1 : 0;
    const size = Point.distance(b2, a2);
    return [a2.x, a2.y + "A" + size, size, 0, sweep, 1, c.x, c.y].join(",");
  }
  function angleSize(angle, options = {}) {
    if (angle.isRight && !options.round)
      return 20;
    return 24 + 20 * (1 - clamp(angle.rad, 0, Math.PI) / Math.PI);
  }
  function drawAngle(angle, options = {}) {
    let a2 = angle.a;
    const b2 = angle.b;
    let c = angle.c;
    const size = options.size || angleSize(angle, options);
    const ba = Point.difference(a2, b2).unitVector;
    const bc = Point.difference(c, b2).unitVector;
    a2 = Point.sum(b2, ba.scale(size));
    c = Point.sum(b2, bc.scale(size));
    let p = options.fill ? `M${b2.x},${b2.y}L` : "M";
    if (angle.isRight && !options.round) {
      const d = Point.sum(a2, bc.scale(size));
      p += `${a2.x},${a2.y}L${d.x},${d.y}L${c.x},${c.y}`;
    } else {
      p += drawArc(a2, b2, c);
    }
    if (options.fill)
      p += "Z";
    return p;
  }
  function drawPath(...points) {
    return "M" + points.map((p) => p.x + "," + p.y).join("L");
  }
  function drawLineMark(x, type) {
    const p = x.perpendicularVector.scale(6);
    const n = x.unitVector.scale(3);
    const m = x.midpoint;
    switch (type) {
      case "bar":
        return drawPath(m.add(p), m.add(p.inverse));
      case "bar2":
        return drawPath(m.add(n).add(p), m.add(n).add(p.inverse)) + drawPath(m.add(n.inverse).add(p), m.add(n.inverse).add(p.inverse));
      case "arrow":
        return drawPath(m.add(n.inverse).add(p), m.add(n), m.add(n.inverse).add(p.inverse));
      case "arrow2":
        return drawPath(m.add(n.scale(-2)).add(p), m, m.add(n.scale(-2)).add(p.inverse)) + drawPath(m.add(p), m.add(n.scale(2)), m.add(p.inverse));
      default:
        return "";
    }
  }
  function arrowPath(start, normal2) {
    if (!start || !normal2)
      return "";
    const perp = normal2.perpendicular;
    const a2 = start.add(normal2.scale(9)).add(perp.scale(9));
    const b2 = start.add(normal2.scale(9)).add(perp.scale(-9));
    return drawPath(a2, start, b2);
  }
  function drawLineArrows(x, type) {
    let path = "";
    if (isOneOf(type, "start", "both")) {
      path += arrowPath(x.p1, x.unitVector);
    }
    if (isOneOf(type, "end", "both")) {
      path += arrowPath(x.p2, x.unitVector.inverse);
    }
    return path;
  }
  function drawArcArrows(x, type) {
    let path = "";
    if (isOneOf(type, "start", "both")) {
      const normal2 = new Line(x.c, x.start).perpendicularVector.inverse;
      path += arrowPath(x.start, normal2);
    }
    if (isOneOf(type, "end", "both")) {
      const normal2 = new Line(x.c, x.end).perpendicularVector;
      path += arrowPath(x.end, normal2);
    }
    return path;
  }
  function drawSVG(obj, options = {}) {
    if (isAngle(obj)) {
      return drawAngle(obj, options);
    }
    if (isSegment(obj)) {
      if (obj.p1.equals(obj.p2))
        return "";
      let line = drawPath(obj.p1, obj.p2);
      if (options.mark)
        line += drawLineMark(obj, options.mark);
      if (options.arrows)
        line += drawLineArrows(obj, options.arrows);
      return line;
    }
    if (isRay(obj)) {
      if (!options.box)
        return "";
      const end = intersections(obj, options.box)[0];
      return end ? drawPath(obj.p1, end) : "";
    }
    if (isLine(obj)) {
      if (!options.box)
        return "";
      const points = intersections(obj, options.box);
      if (points.length < 2)
        return "";
      let line = drawPath(points[0], points[1]);
      if (options.mark)
        line += drawLineMark(obj, options.mark);
      return line;
    }
    if (isCircle(obj)) {
      return `M ${obj.c.x - obj.r} ${obj.c.y} a ${obj.r},${obj.r} 0 1 0 ${2 * obj.r} 0 a ${obj.r} ${obj.r} 0 1 0 ${-2 * obj.r} 0`;
    }
    if (isArc(obj)) {
      let path = "M" + drawArc(obj.start, obj.c, obj.end);
      if (options.arrows)
        path += drawArcArrows(obj, options.arrows);
      return path;
    }
    if (isSector(obj)) {
      return `M ${obj.c.x} ${obj.c.y} L ${drawArc(obj.start, obj.c, obj.end)} Z`;
    }
    if (isPolyline(obj)) {
      return drawPath(...obj.points);
    }
    if (isPolygon(obj)) {
      return drawPath(...obj.points) + "Z";
    }
    if (isRectangle(obj)) {
      return drawPath(...obj.polygon.points) + "Z";
    }
    return "";
  }

  // node_modules/@mathigon/boost/dist/boost.esm.js
  
  function __awaiter(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }
  function toQueryString(data) {
    const pairs = [];
    for (let key of Object.keys(data)) {
      let value = data[key];
      key = encodeURIComponent(key);
      if (value == void 0) {
        pairs.push(key);
        continue;
      }
      value = Array.isArray(value) ? value.join(",") : "" + value;
      value = value.replace(/(\r)?\n/g, "\r\n");
      value = encodeURIComponent(value);
      value = value.replace(/%20/g, "+");
      pairs.push(key + "=" + value);
    }
    return pairs.join("&");
  }
  function post(url, data) {
    return __awaiter(this, void 0, void 0, function* () {
      const isForm = data instanceof FormData;
      const options = {
        method: "POST",
        body: isForm ? data : data ? toQueryString(data) : void 0,
        headers: {"X-CSRF-Token": window.csrfToken || ""}
      };
      if (!isForm)
        options.headers["Content-Type"] = "application/x-www-form-urlencoded";
      const ext = url.includes("?") ? "&xhr=1" : "?xhr=1";
      const response = yield fetch(url + ext, options);
      if (!response.ok)
        throw new Error(`Fetch error ${response.status}: ${url}`);
      return response.text();
    });
  }
  function loadImage(url, credentials = false) {
    return new Promise((resolve) => {
      const img = new Image();
      if (!credentials)
        img.crossOrigin = "Anonymous";
      img.onload = () => resolve(img);
      img.src = url;
    });
  }
  var POST_DATA = new Map();
  function savePostData(url, data) {
    if (POST_DATA.has(url)) {
      deepExtend(POST_DATA.get(url), data, (a2, b2) => unique(a2.concat(b2)));
    } else {
      POST_DATA.set(url, data);
    }
  }
  function sendPostData() {
    if (!window.navigator.onLine)
      return;
    for (const [url, data] of POST_DATA) {
      POST_DATA.delete(url);
      post(url, {data: JSON.stringify(data)}).catch((error) => {
        console.error("Failed to send POST request:", error);
        savePostData(url, data);
      });
    }
  }
  var doDeferredPost = throttle(sendPostData, 5e3);
  window.addEventListener("online", doDeferredPost);
  window.onbeforeunload = sendPostData;
  var NODE_TYPE;
  (function(NODE_TYPE2) {
    NODE_TYPE2[NODE_TYPE2["Array"] = 0] = "Array";
    NODE_TYPE2[NODE_TYPE2["BinaryOp"] = 1] = "BinaryOp";
    NODE_TYPE2[NODE_TYPE2["Call"] = 2] = "Call";
    NODE_TYPE2[NODE_TYPE2["Conditional"] = 3] = "Conditional";
    NODE_TYPE2[NODE_TYPE2["Identifier"] = 4] = "Identifier";
    NODE_TYPE2[NODE_TYPE2["Literal"] = 5] = "Literal";
    NODE_TYPE2[NODE_TYPE2["Member"] = 6] = "Member";
    NODE_TYPE2[NODE_TYPE2["UnaryOp"] = 7] = "UnaryOp";
  })(NODE_TYPE || (NODE_TYPE = {}));
  var BINARY_OPS = {
    "===": (a2, b2) => a2 === b2,
    "!==": (a2, b2) => a2 !== b2,
    "||": (a2, b2) => a2 || b2,
    "&&": (a2, b2) => a2 && b2,
    "==": (a2, b2) => a2 == b2,
    "!=": (a2, b2) => a2 != b2,
    "<=": (a2, b2) => a2 <= b2,
    ">=": (a2, b2) => a2 >= b2,
    "**": (a2, b2) => Math.pow(a2, b2),
    "<": (a2, b2) => a2 < b2,
    ">": (a2, b2) => a2 > b2,
    "+": (a2, b2) => a2 + b2,
    "-": (a2, b2) => a2 - b2,
    "*": (a2, b2) => a2 * b2,
    "/": (a2, b2) => a2 / b2,
    "%": (a2, b2) => a2 % b2
  };
  var UNARY_OPS = {
    "-": (a2) => -a2,
    "+": (a2) => +a2,
    "!": (a2) => !a2
  };
  var BINARY_PRECEDENCE = {
    "||": 1,
    "&&": 2,
    "==": 3,
    "!=": 3,
    "===": 3,
    "!==": 3,
    "<": 4,
    ">": 4,
    "<=": 4,
    ">=": 4,
    "+": 5,
    "-": 5,
    "*": 6,
    "/": 6,
    "%": 6,
    "**": 7
  };
  var LITERALS = {
    true: true,
    false: false,
    undefined: void 0
  };
  var SPACE = /\s/;
  var DIGIT = /[0-9]/;
  var IDENTIFIER_START = /[a-zA-Zα-ωΑ-Ω$_]/;
  var IDENTIFIER_PART = /[0-9a-zA-Zα-ωΑ-Ω$_]/;
  function parseSyntaxTree(expr) {
    const length = expr.length;
    let index = 0;
    function throwError(message) {
      throw new Error(`${message} at character ${index} of "${expr}"`);
    }
    function gobbleSpaces() {
      while (SPACE.test(expr[index]))
        index += 1;
    }
    function gobbleNumericLiteral() {
      let number = "";
      while (DIGIT.test(expr[index]))
        number += expr[index++];
      if (expr[index] === ".") {
        number += expr[index++];
        while (DIGIT.test(expr[index]))
          number += expr[index++];
      }
      const char = expr[index];
      if (char && IDENTIFIER_START.test(char)) {
        const name = number + expr[index];
        throwError(`Variable names cannot start with a number (${name})`);
      } else if (char === ".") {
        throwError("Unexpected period");
      }
      return {type: NODE_TYPE.Literal, value: parseFloat(number)};
    }
    function gobbleStringLiteral() {
      const quote = expr[index];
      index += 1;
      let closed = false;
      let string = "";
      while (index < length) {
        const char = expr[index++];
        if (char === quote) {
          closed = true;
          break;
        }
        string += char;
      }
      if (!closed)
        throwError(`Unclosed quote after "${string}"`);
      return {type: NODE_TYPE.Literal, value: string};
    }
    function gobbleIdentifier() {
      let name = expr[index];
      if (!IDENTIFIER_START.test(expr[index]))
        throwError("Unexpected " + name);
      index += 1;
      while (index < length) {
        if (IDENTIFIER_PART.test(expr[index])) {
          name += expr[index++];
        } else {
          break;
        }
      }
      if (name in LITERALS) {
        return {type: NODE_TYPE.Literal, value: LITERALS[name]};
      } else {
        return {type: NODE_TYPE.Identifier, name};
      }
    }
    function gobbleArguments(termination) {
      const args = [];
      let closed = false;
      let lastArg = void 0;
      while (index < length) {
        if (expr[index] === termination) {
          if (lastArg)
            args.push(lastArg);
          closed = true;
          index += 1;
          break;
        } else if (expr[index] === ",") {
          args.push(lastArg || {type: NODE_TYPE.Literal, value: void 0});
          index += 1;
        } else {
          lastArg = gobbleExpression();
        }
      }
      if (!closed)
        throwError("Expected " + termination);
      return args;
    }
    function gobbleVariable() {
      let node2;
      if (expr[index] === "(") {
        index += 1;
        node2 = gobbleExpression();
        gobbleSpaces();
        if (expr[index] === ")") {
          index += 1;
          return node2;
        } else {
          throwError("Unclosed (");
        }
      } else {
        node2 = gobbleIdentifier();
      }
      gobbleSpaces();
      while (".[(".includes(expr[index])) {
        if (expr[index] === ".") {
          index++;
          gobbleSpaces();
          node2 = {
            type: NODE_TYPE.Member,
            object: node2,
            computed: false,
            property: gobbleIdentifier()
          };
        } else if (expr[index] === "[") {
          index++;
          node2 = {
            type: NODE_TYPE.Member,
            object: node2,
            computed: true,
            property: gobbleExpression()
          };
          gobbleSpaces();
          if (expr[index] !== "]")
            throwError("Unclosed [");
          index++;
        } else if (expr[index] === "(") {
          index++;
          node2 = {
            type: NODE_TYPE.Call,
            args: gobbleArguments(")"),
            callee: node2
          };
        }
        gobbleSpaces();
      }
      return node2;
    }
    function gobbleBinaryOp() {
      gobbleSpaces();
      for (const length2 of [3, 2, 1]) {
        const substr = expr.substr(index, length2);
        if (substr in BINARY_OPS) {
          index += length2;
          return substr;
        }
      }
    }
    function gobbleToken() {
      gobbleSpaces();
      const operator = expr[index];
      if (DIGIT.test(operator) || operator === ".") {
        return gobbleNumericLiteral();
      } else if (operator === "'" || operator === '"') {
        return gobbleStringLiteral();
      } else if (operator === "[") {
        index += 1;
        return {type: NODE_TYPE.Array, elements: gobbleArguments("]")};
      } else if (operator in UNARY_OPS) {
        index += 1;
        return {type: NODE_TYPE.UnaryOp, operator, argument: gobbleToken()};
      } else if (IDENTIFIER_START.test(operator) || operator === "(") {
        return gobbleVariable();
      }
      throwError("Expression parsing error");
    }
    function gobbleBinaryExpression() {
      let left = gobbleToken();
      let biop = gobbleBinaryOp();
      if (!biop)
        return left;
      let right = gobbleToken();
      if (!right)
        throwError("Expected expression after " + biop);
      let node2;
      const stack = [left, biop, right];
      while (biop = gobbleBinaryOp()) {
        const prec = BINARY_PRECEDENCE[biop];
        const curBiop = biop;
        while (stack.length > 2 && prec <= BINARY_PRECEDENCE[stack[stack.length - 2]]) {
          right = stack.pop();
          biop = stack.pop();
          left = stack.pop();
          node2 = {type: NODE_TYPE.BinaryOp, operator: biop, left, right};
          stack.push(node2);
        }
        node2 = gobbleToken();
        if (!node2)
          throwError("Expected expression after " + curBiop);
        stack.push(curBiop, node2);
      }
      let i = stack.length - 1;
      node2 = stack[i];
      while (i > 1) {
        node2 = {
          type: NODE_TYPE.BinaryOp,
          operator: stack[i - 1],
          left: stack[i - 2],
          right: node2
        };
        i -= 2;
      }
      return node2;
    }
    function gobbleExpression() {
      const test = gobbleBinaryExpression();
      gobbleSpaces();
      if (test && expr[index] === "?") {
        index += 1;
        const consequent = gobbleExpression();
        if (!consequent)
          throwError("Expected expression");
        gobbleSpaces();
        if (expr[index] === ":") {
          index++;
          const alternate = gobbleExpression();
          if (!alternate)
            throwError("Expected expression");
          return {type: NODE_TYPE.Conditional, test, consequent, alternate};
        } else {
          throwError("Expected :");
        }
      } else {
        return test;
      }
    }
    const node = gobbleExpression();
    if (index < expr.length)
      throwError(`Unexpected "${expr[index]}"`);
    return node;
  }
  var EMPTY = [void 0, void 0];
  function evaluate(node, context, local) {
    switch (node.type) {
      case NODE_TYPE.Array:
        const v1 = node.elements.map((n) => evaluate(n, context, local)[0]);
        if (v1.some((v) => v === void 0))
          return EMPTY;
        return [v1, void 0];
      case NODE_TYPE.BinaryOp:
        const left = evaluate(node.left, context, local)[0];
        const right = evaluate(node.right, context, local)[0];
        if ("+-**/%".includes(node.operator) && (left === void 0 || right === void 0))
          return EMPTY;
        return [BINARY_OPS[node.operator](left, right), void 0];
      case NODE_TYPE.Call:
        const [fn, self] = evaluate(node.callee, context, local);
        const args = node.args.map((n) => evaluate(n, context, local)[0]);
        if (args.some((v) => v === void 0) || typeof fn !== "function")
          return EMPTY;
        return [fn.apply(self, args), void 0];
      case NODE_TYPE.Conditional:
        const consequent = evaluate(node.consequent, context, local);
        const alternate = evaluate(node.alternate, context, local);
        return evaluate(node.test, context, local)[0] ? consequent : alternate;
      case NODE_TYPE.Identifier:
        return [local[node.name] || context[node.name], void 0];
      case NODE_TYPE.Literal:
        return [node.value, void 0];
      case NODE_TYPE.Member:
        const object = evaluate(node.object, context, local)[0];
        const property = node.computed ? evaluate(node.property, context, local)[0] : node.property.name;
        return object ? [object[property], object] : [void 0, void 0];
      case NODE_TYPE.UnaryOp:
        const arg = evaluate(node.argument, context, local)[0];
        if (arg === void 0 && node.operator !== "!")
          return EMPTY;
        return [UNARY_OPS[node.operator](arg), void 0];
    }
  }
  function compile(expr) {
    const node = parseSyntaxTree(expr);
    if (!node)
      return (_context = {}) => void 0;
    return (context = {}, local = {}) => evaluate(node, context, local)[0];
  }
  var TEMPLATE = /\${([^}]+)}/g;
  function compileString(expr) {
    const parts = expr.split(TEMPLATE);
    const fns = parts.map((p, i) => i % 2 ? compile(p.replace(/×/g, "*")) : void 0);
    return (context) => {
      return parts.map((p, i) => {
        if (!(i % 2))
          return p;
        const value = fns[i](context);
        return typeof value === "number" && value < 0 ? "\u2013" + -value : value;
      }).join("");
    };
  }
  var touchSupport = "ontouchstart" in window;
  var pointerSupport = "onpointerdown" in window;
  function pointerPosition(e) {
    if (e.touches) {
      const touches = e.targetTouches.length ? e.targetTouches : e.changedTouches;
      return new Point(touches[0].clientX, touches[0].clientY);
    } else {
      return new Point(e.clientX || 0, e.clientY || 0);
    }
  }
  function getEventTarget(event) {
    if (event instanceof PointerEvent && event.pointerType === "mouse") {
      return $(event.target);
    }
    const posn = pointerPosition(event);
    return $(document.elementFromPoint(posn.x, posn.y) || void 0);
  }
  function makeTapEvent($el) {
    if ($el._data["tapEvent"])
      return;
    $el._data["tapEvent"] = true;
    let start = void 0;
    $el.on("pointerdown", (e) => start = pointerPosition(e));
    $el.on("pointerup", (e) => {
      if (!start)
        return;
      const end = pointerPosition(e);
      if (Point.distance(start, end) < 6)
        $el.trigger("tap", e);
      start = void 0;
    });
    $el.on("pointercancel", () => start = void 0);
  }
  function makeClickOutsideEvent($el) {
    if ($el._data["clickOutsideEvent"])
      return;
    $el._data["clickOutsideEvent"] = true;
    $body.on("pointerdown", (e) => {
      const $target = $(e.target);
      if ($target && ($target.equals($el) || $target.hasParent($el)))
        return;
      $el.trigger("clickOutside", e);
    });
  }
  function makeScrollEvents($el) {
    if ($el._data["scrollEvents"])
      return;
    $el._data["scrollEvents"] = true;
    let ticking = false;
    let top = void 0;
    function tick() {
      const newTop = $el.scrollTop;
      if (newTop === top) {
        ticking = false;
        return;
      }
      top = newTop;
      $el.trigger("scroll", {top});
      window.requestAnimationFrame(tick);
    }
    function scroll() {
      if (!ticking)
        window.requestAnimationFrame(tick);
      ticking = true;
    }
    const target = $el.type === "window" ? window : $el._el;
    target.addEventListener("scroll", scroll);
    function touchStart() {
      window.addEventListener("touchmove", scroll);
      window.addEventListener("touchend", touchEnd);
    }
    function touchEnd() {
      window.removeEventListener("touchmove", scroll);
      window.removeEventListener("touchend", touchEnd);
    }
    $el._el.addEventListener("touchstart", function(e) {
      if (!e.handled)
        touchStart();
    });
  }
  var observer;
  function intersectionCallback(entries) {
    for (const e of entries) {
      const event = e.isIntersecting ? "enterViewport" : "exitViewport";
      setTimeout(() => $(e.target).trigger(event));
    }
  }
  function makeIntersectionEvents($el) {
    if ($el._data["intersectionEvents"])
      return;
    $el._data["intersectionEvents"] = true;
    if (!window.IntersectionObserver) {
      let wasVisible = false;
      $body.on("scroll", () => {
        const isVisible = $el.isInViewport;
        if (wasVisible && !isVisible) {
          $el.trigger("exitViewport");
          wasVisible = false;
        } else if (isVisible && !wasVisible) {
          $el.trigger("enterViewport");
          wasVisible = true;
        }
      });
      return;
    }
    if (!observer)
      observer = new IntersectionObserver(intersectionCallback);
    observer.observe($el._el);
  }
  function makeResizeEvents($el, remove = false) {
    if (remove) {
      if ($el._data["resizeObserver"])
        $el._data["resizeObserver"].disconnect();
      $el._data["resizeObserver"] = void 0;
    }
    if ($el._data["resizeObserver"])
      return;
    if (window.ResizeObserver) {
      const observer2 = new window.ResizeObserver(() => $el.trigger("resize"));
      observer2.observe($el._el);
      $el._data["resizeObserver"] = observer2;
    } else if (window.MutationObserver) {
      const observer2 = new MutationObserver(() => $el.trigger("resize"));
      observer2.observe($el._el, {attributes: true, childList: true, characterData: true, subtree: true});
      $el._data["resizeObserver"] = observer2;
    }
  }
  function makePointerPositionEvents($el) {
    if ($el._data["pointerPositionEvents"])
      return;
    $el._data["pointerPositionEvents"] = true;
    const parent = $el.parent;
    let isInside = void 0;
    parent.on("pointerend", () => isInside = void 0);
    parent.on("pointermove", (e) => {
      const wasInside = isInside;
      const target = getEventTarget(e);
      isInside = target.equals($el) || target.hasParent($el);
      if (wasInside != void 0 && isInside && !wasInside)
        $el.trigger("pointerenter", e);
      if (!isInside && wasInside)
        $el.trigger("pointerleave", e);
    });
  }
  function makeMouseEvent(eventName, $el) {
    if ($el._data["_" + eventName])
      return;
    $el._data["_" + eventName] = true;
    if (pointerSupport) {
      $el.on(eventName.replace("mouse", "pointer"), (e) => {
        if (e.pointerType === "mouse")
          $el.trigger(eventName, e);
      });
    } else if (!touchSupport) {
      $el._el.addEventListener(eventName, (e) => $el.trigger(eventName, e));
    }
  }
  function makeKeyEvent($el) {
    $el.on("keydown", (e) => {
      if (e.metaKey || e.ctrlKey)
        return;
      if (Browser.isAndroid && e.keyCode === 229)
        return;
      const char = e.key || String.fromCharCode(e.which);
      const key = char.toLowerCase();
      $el.trigger("key", {code: e.keyCode, key, char});
    });
    if (Browser.isAndroid && $el.type === "input") {
      $el.on("input", (e) => {
        const char = e.data[e.data.length - 1];
        const key = char.toLowerCase();
        $el.trigger("key", {code: void 0, key, char});
        $el.value = "";
      });
    }
  }
  var aliases = {
    scrollwheel: "DOMMouseScroll mousewheel",
    pointerdown: pointerSupport ? "pointerdown" : touchSupport ? "touchstart" : "mousedown",
    pointermove: pointerSupport ? "pointermove" : touchSupport ? "touchmove" : "mousemove",
    pointerup: pointerSupport ? "pointerup" : touchSupport ? "touchend" : "mouseup",
    pointercancel: pointerSupport ? "pointercancel" : "touchcancel",
    pointerstop: pointerSupport ? "pointerup pointercancel" : touchSupport ? "touchend touchcancel" : "mouseup"
  };
  var customEvents = {
    scroll: makeScrollEvents,
    tap: makeTapEvent,
    clickOutside: makeClickOutsideEvent,
    key: makeKeyEvent,
    mousedown: makeMouseEvent.bind(void 0, "mousedown"),
    mousemove: makeMouseEvent.bind(void 0, "mousemove"),
    mouseup: makeMouseEvent.bind(void 0, "mouseup"),
    pointerenter: makePointerPositionEvents,
    pointerleave: makePointerPositionEvents,
    enterViewport: makeIntersectionEvents,
    exitViewport: makeIntersectionEvents,
    resize: makeResizeEvents
  };
  function bindEvent($el, event, fn, options) {
    if (event in customEvents) {
      customEvents[event]($el, false);
    } else if (event in aliases) {
      const events = words(aliases[event]);
      for (const e of events)
        $el._el.addEventListener(e, fn, options);
    } else {
      $el._el.addEventListener(event, fn, options);
    }
  }
  function unbindEvent($el, event, fn) {
    if (event in customEvents) {
      if (!$el._events[event] || !$el._events[event].length) {
        customEvents[event]($el, true);
      }
    } else if (fn && event in aliases) {
      const events = words(aliases[event]);
      for (const e of events)
        $el._el.removeEventListener(e, fn);
    } else if (fn) {
      $el._el.removeEventListener(event, fn);
    }
  }
  function observe(state, parentModel) {
    const callbackMap = new Map();
    const computedKeys = new Map();
    let pendingCallback = void 0;
    let lastKey = 0;
    function watch(callback) {
      pendingCallback = callback;
      const result = callback(proxy);
      pendingCallback = void 0;
      return result;
    }
    function unwatch(callback) {
      for (const callbacks of callbackMap.values()) {
        if (callbacks.has(callback))
          callbacks.delete(callback);
      }
    }
    function setComputed(key, expr) {
      if (computedKeys.has(key))
        unwatch(computedKeys.get(key));
      const callback = () => {
        state[key] = expr(proxy);
        if (pendingCallback === callback)
          pendingCallback = void 0;
        triggerCallbacks(key);
      };
      computedKeys.set(key, callback);
      watch(callback);
    }
    function triggerCallbacks(key) {
      const callbacks = callbackMap.get(key);
      if (callbacks) {
        for (const callback of callbacks)
          callback(state);
      }
    }
    function forceUpdate() {
      for (const callbacks of callbackMap.values()) {
        for (const callback of callbacks)
          callback(state);
      }
    }
    function assign2(changes) {
      Object.assign(state, changes);
      forceUpdate();
    }
    function getKey() {
      lastKey += 1;
      while ("_x" + lastKey in state)
        lastKey += 1;
      return "_x" + lastKey;
    }
    function clear() {
      state = {};
      callbackMap.clear();
      computedKeys.clear();
      lastKey = 0;
    }
    function inherit(key) {
      if (!parentModel)
        return;
      parentModel.watch(() => proxy[key] = parentModel[key]);
    }
    const proxy = new Proxy(state, {
      get(_, key) {
        if (key === "watch")
          return watch;
        if (key === "unwatch")
          return unwatch;
        if (key === "setComputed")
          return setComputed;
        if (key === "forceUpdate")
          return forceUpdate;
        if (key === "assign")
          return assign2;
        if (key === "getKey")
          return getKey;
        if (key === "clear")
          return clear;
        if (key === "_internal")
          return [state, callbackMap];
        if (pendingCallback) {
          if (!callbackMap.has(key))
            callbackMap.set(key, new Set());
          callbackMap.get(key).add(pendingCallback);
        }
        if (!(key in state))
          inherit(key);
        return state[key];
      },
      set(_, key, value) {
        if (state[key] === value)
          return true;
        state[key] = value;
        if (computedKeys.has(key)) {
          unwatch(computedKeys.get(key));
          computedKeys.delete(key);
        }
        triggerCallbacks(key);
        return true;
      },
      deleteProperty(_, p) {
        delete state[p];
        callbackMap.delete(p);
        computedKeys.delete(p);
        return true;
      }
    });
    return proxy;
  }
  var pathLength = {A: 7, C: 6, H: 1, L: 2, M: 2, Q: 4, S: 4, T: 2, V: 1, Z: 0};
  var pathSegment = /[astvzqmhlc]([^astvzqmhlc]*)/ig;
  var pathPoint = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;
  function pathCommands(path) {
    const commands = [];
    let lastPoint = void 0;
    for (const match of path.match(pathSegment) || []) {
      const uType = match[0].toUpperCase();
      if (uType === "Z") {
        commands.push({type: "Z", points: []});
        continue;
      }
      const args = (match.slice(1).match(pathPoint) || []).map((p) => +p);
      const isAbsolute = uType === match[0];
      for (const [i, p] of chunk(args, pathLength[uType]).entries()) {
        let points = [];
        let type = uType === "M" && i > 0 ? "L" : uType;
        let options = void 0;
        if (uType === "H") {
          type = "L";
          points = [new Point(p[0], isAbsolute ? (lastPoint === null || lastPoint === void 0 ? void 0 : lastPoint.y) || 0 : 0)];
        } else if (uType === "V") {
          type = "L";
          points = [new Point(isAbsolute ? (lastPoint === null || lastPoint === void 0 ? void 0 : lastPoint.x) || 0 : 0, p[0])];
        } else if (uType === "A") {
          type = "A";
          points = [new Point(p[5], p[6])];
          options = p.slice(0, 5);
        } else if ("MLCSQT".includes(uType)) {
          points = chunk(p, 2).map((q) => new Point(q[0], q[1]));
        }
        if (!isAbsolute && lastPoint)
          points = points.map((p2) => p2.translate(lastPoint));
        lastPoint = last(points);
        commands.push({type, points, options});
      }
    }
    return commands;
  }
  function parsePath(d) {
    if (!d)
      return [];
    const commands = pathCommands(d);
    return commands.map((c) => last(c.points)).filter((p) => !!p);
  }
  var BaseView = class {
    constructor(_el) {
      this._el = _el;
      this._data = {};
      this._events = {};
      this.type = "default";
      _el._view = this;
    }
    get id() {
      return this._el.id;
    }
    get data() {
      return this._el.dataset;
    }
    get tagName() {
      return this._el.tagName.toUpperCase();
    }
    equals(el) {
      return this._el === el._el;
    }
    addClass(className) {
      for (const c of words(className))
        this._el.classList.add(c);
    }
    removeClass(className) {
      for (const c of words(className))
        this._el.classList.remove(c);
    }
    hasClass(className) {
      return this._el.classList.contains(className);
    }
    toggleClass(className) {
      return this._el.classList.toggle(className);
    }
    setClass(className, condition) {
      if (condition) {
        this.addClass(className);
      } else {
        this.removeClass(className);
      }
    }
    attr(attr) {
      return this._el.getAttribute(attr) || "";
    }
    hasAttr(attr) {
      return this._el.hasAttribute(attr);
    }
    setAttr(attr, value) {
      if (value === void 0) {
        this.removeAttr(attr);
      } else {
        this._el.setAttribute(attr, value.toString());
      }
    }
    removeAttr(attr) {
      this._el.removeAttribute(attr);
    }
    get attributes() {
      return Array.from(this._el.attributes || []);
    }
    get html() {
      return this._el.innerHTML || "";
    }
    set html(h) {
      this._el.innerHTML = h;
    }
    get text() {
      return this._el.textContent || "";
    }
    set text(t) {
      this._el.textContent = t;
    }
    set textStr(t) {
      this._el.textContent = "" + t;
    }
    blur() {
      this._el.blur();
    }
    focus() {
      this._el.focus();
    }
    getParentModel() {
      const parent = this.parent;
      return parent ? parent.model || parent.getParentModel() : void 0;
    }
    bindModel(model, recursive = true) {
      var _a3;
      if (this.model)
        return;
      this.model = model;
      if (this.hasAttr(":for"))
        return this.makeDynamicList(model);
      for (const {name, value} of this.attributes) {
        this.makeDynamicAttribute(name, value, model);
      }
      for (const $c of this.childNodes) {
        if ($c instanceof Text) {
          if ((_a3 = $c.textContent) === null || _a3 === void 0 ? void 0 : _a3.includes("${")) {
            const expr = compileString($c.textContent);
            model.watch(() => $c.textContent = expr(model) || "");
          }
        } else if (recursive) {
          $c.bindModel(model);
        }
      }
    }
    bindVariable(_model, _name) {
    }
    makeDynamicAttribute(name, value, model) {
      if (name.startsWith("@")) {
        const event = name.slice(1);
        const expr = compile(value);
        this.on(event, (e) => expr(model, {$event: e}));
      } else if (name === ":show") {
        const expr = compile(value);
        model.watch(() => this.toggle(!!expr(model)));
      } else if (name === ":if") {
        const expr = compile(value);
        const $placeholder = $(document.createComment(""));
        this.insertBefore($placeholder);
        let visible = true;
        model.watch(() => {
          const show = !!expr(model);
          if (show === visible)
            return;
          if (show)
            $placeholder.insertBefore(this);
          if (!show)
            this.detach();
          visible = show;
        });
      } else if (name === ":html") {
        const expr = compile(value);
        model.watch(() => this.html = expr(model) || "");
      } else if (name === ":draw") {
        const expr = compile(value);
        model.watch(() => this.draw(expr(model)));
      } else if (name === ":class") {
        const expr = compile(value);
        const initialClass = this.attr("class") + " ";
        model.watch(() => this.setAttr("class", initialClass + expr(model)));
      } else if (name === ":bind") {
        this.bindVariable(model, value);
      } else if (name.startsWith(":")) {
        const expr = compile(value);
        const attr = name.slice(1);
        model.watch(() => this.setAttr(attr, expr(model)));
      } else if (value.includes("${")) {
        const expr = compileString(value);
        model.watch(() => this.setAttr(name, expr(model) || ""));
      }
      if (name.startsWith("@") || name.startsWith(":"))
        this.removeAttr(name);
    }
    makeDynamicList(model) {
      const [name, value] = this.attr(":for").split(" in ");
      this.removeAttr(":for");
      const expr = compile(value);
      const $placeholder = $(document.createComment(""));
      this.insertBefore($placeholder);
      this.detach();
      const $cached = [];
      let visible = 0;
      model.watch(() => {
        let array = expr(model);
        if (!Array.isArray(array))
          array = [];
        for (let i = array.length; i < visible; ++i)
          $cached[i].detach();
        for (let i = visible; i < $cached.length; ++i)
          $placeholder.insertBefore($cached[i]);
        for (let i = $cached.length; i < array.length; ++i) {
          const $el = this.copy(true);
          $el.bindModel(observe({[name]: void 0}, model));
          $placeholder.insertBefore($el);
          $cached.push($el);
        }
        visible = array.length;
        for (let i = 0; i < visible; ++i)
          $cached[i].model[name] = array[i];
      });
    }
    get bounds() {
      return this._el.getBoundingClientRect();
    }
    get boundsRect() {
      const bounds = this.bounds;
      return new Rectangle(new Point(bounds.x, bounds.y), bounds.width, bounds.height);
    }
    contains(point) {
      this.boundsRect.contains(point);
    }
    get isInViewport() {
      if (this.height === 0)
        return false;
      const bounds = this.bounds;
      return isBetween(bounds.top, -bounds.height, Browser.height);
    }
    get topLeftPosition() {
      const bounds = this.bounds;
      return new Point(bounds.left, bounds.top);
    }
    get boxCenter() {
      const box = this.bounds;
      return new Point(box.left + box.width / 2, box.top + box.height / 2);
    }
    get scrollWidth() {
      return this._el.scrollWidth;
    }
    get scrollHeight() {
      return this._el.scrollHeight;
    }
    get scrollTop() {
      return this._el.scrollTop;
    }
    set scrollTop(y) {
      this._el.scrollTop = y;
      this.trigger("scroll", {top: y, left: this.scrollLeft});
    }
    get scrollLeft() {
      return this._el.scrollLeft;
    }
    set scrollLeft(x) {
      this._el.scrollLeft = x;
      this.trigger("scroll", {top: this.scrollTop, left: x});
    }
    scrollTo(pos, time = 1e3, easing = "cubic") {
      if (pos < 0)
        pos = 0;
      const startPosition = this.scrollTop;
      const distance = pos - startPosition;
      if (this._data["scrollAnimation"])
        this._data["scrollAnimation"].cancel();
      this._data["scrollAnimation"] = animate((t) => {
        const y = startPosition + distance * ease(easing, t);
        this.scrollTop = y;
        this.trigger("scroll", {top: y});
      }, time);
    }
    scrollBy(distance, time = 1e3, easing = "cubic") {
      if (!distance)
        return;
      this.scrollTo(this.scrollTop + distance, time, easing);
    }
    css(props, value) {
      if (value === void 0) {
        if (typeof props === "string") {
          return window.getComputedStyle(this._el).getPropertyValue(props);
        } else {
          const keys = Object.keys(props);
          for (const p of keys)
            this._el.style.setProperty(p, "" + props[p]);
        }
      } else if (typeof props === "string") {
        this._el.style.setProperty(props, "" + value);
      }
    }
    get transform() {
      return this.css("transform").replace("none", "");
    }
    get transformMatrix() {
      const transform = this.transform;
      if (!transform)
        return [[1, 0, 0], [0, 1, 0]];
      const coords = transform.match(/matrix\(([0-9,.\s-]*)\)/);
      if (!coords || !coords[1])
        return [[1, 0, 0], [0, 1, 0]];
      const matrix = coords[1].split(",");
      return [
        [+matrix[0], +matrix[2], +matrix[4]],
        [+matrix[1], +matrix[3], +matrix[5]]
      ];
    }
    get scale() {
      const matrix = this.transformMatrix;
      return [matrix[0][0], matrix[1][1]];
    }
    setTransform(posn, angle = 0, scale = 1) {
      let t = "";
      if (posn)
        t += `translate(${roundTo(posn.x, 0.1)}px,${roundTo(posn.y, 0.1)}px)`;
      if (angle)
        t += ` rotate(${angle}rad)`;
      if (scale)
        t += ` scale(${scale})`;
      this._el.style.transform = t;
    }
    translate(x, y) {
      this.setTransform(new Point(x, y));
    }
    show() {
      if (this.hasAttr("hidden"))
        this.removeAttr("hidden");
      if (this.data["display"] === "visibility") {
        this._el.style.visibility = "visible";
      } else {
        this._el.style.display = this.data.display || "block";
      }
    }
    hide() {
      if (this.data["display"] === "visibility") {
        this._el.style.visibility = "hidden";
      } else {
        this._el.style.display = "none";
      }
    }
    toggle(show) {
      if (show) {
        this.show();
      } else {
        this.hide();
      }
    }
    is(selector) {
      if (this._el.matches)
        return this._el.matches(selector);
      return Array.from(document.querySelectorAll(selector)).includes(this._el);
    }
    index() {
      let i = 0;
      let child = this._el;
      while ((child = child.previousSibling || void 0) !== void 0)
        ++i;
      return i;
    }
    prepend(newChild) {
      const children = this._el.childNodes;
      if (children.length) {
        this._el.insertBefore(newChild._el, children[0]);
      } else {
        this._el.appendChild(newChild._el);
      }
    }
    append(newChild) {
      this._el.appendChild(newChild instanceof Text ? newChild : newChild._el);
    }
    insertBefore(newChild) {
      this.parent._el.insertBefore(newChild._el, this._el);
    }
    insertAfter(newChild) {
      const next = this._el.nextSibling;
      if (next) {
        this.parent._el.insertBefore(newChild._el, next);
      } else {
        this.parent._el.appendChild(newChild._el);
      }
    }
    get next() {
      return $(this._el.nextSibling);
    }
    get prev() {
      return $(this._el.previousSibling);
    }
    $(selector) {
      return $(selector, this);
    }
    $$(selector) {
      return $$(selector, this);
    }
    get parent() {
      return $(this._el.parentElement || void 0);
    }
    parents(selector) {
      const result = [];
      let parent = this.parent;
      while (parent) {
        if (!selector || parent.is(selector))
          result.push(parent);
        parent = parent.parent;
      }
      return result;
    }
    hasParent(...$p) {
      const tests = $p.map((p) => p._el);
      let parent = this._el.parentNode;
      while (parent) {
        if (isOneOf(parent, ...tests))
          return true;
        parent = parent.parentNode;
      }
      return false;
    }
    get children() {
      return Array.from(this._el.children || [], (n) => $(n));
    }
    get childNodes() {
      return Array.from(this._el.childNodes, (node) => {
        if (node instanceof Comment)
          return void 0;
        if (node instanceof Text)
          return node;
        return $(node);
      }).filter((x) => x);
    }
    restartAnimation() {
      const n = this.next;
      const p = this.parent;
      this.detach();
      n ? n.insertBefore(this) : p.append(this);
    }
    detach() {
      if (this._el && this._el.parentNode) {
        this._el.parentNode.removeChild(this._el);
      }
    }
    remove() {
      this.detach();
    }
    removeChildren() {
      while (this._el.firstChild)
        this._el.removeChild(this._el.firstChild);
    }
    on(events, callback, options) {
      for (const e of words(events)) {
        if (e in this._events) {
          if (!this._events[e].includes(callback))
            this._events[e].push(callback);
        } else {
          this._events[e] = [callback];
        }
        bindEvent(this, e, callback, options);
      }
    }
    one(events, callback, options) {
      const callbackWrap = (e) => {
        this.off(events, callbackWrap);
        callback(e);
      };
      this.on(events, callbackWrap, options);
    }
    off(events, callback) {
      for (const e of words(events)) {
        if (e in this._events) {
          this._events[e] = callback ? this._events[e].filter((fn) => fn !== callback) : [];
        }
        unbindEvent(this, e, callback);
      }
    }
    trigger(events, args = {}) {
      for (const e of words(events)) {
        if (!this._events[e])
          return;
        for (const fn of this._events[e])
          fn.call(this, args);
      }
    }
    onKeyDown(keys, callback) {
      const keylist = words(keys).map((k) => KEY_CODES[k] || k);
      this._el.addEventListener("keydown", (e) => {
        if (keylist.indexOf(e.keyCode) >= 0)
          callback(e);
      });
    }
    onAttr(name, callback) {
      const observer2 = new MutationObserver((mutations) => {
        for (const m of mutations) {
          if (m.type === "attributes" && m.attributeName === name) {
            callback(this.attr(name));
          }
        }
      });
      observer2.observe(this._el, {attributes: true});
      callback(this.attr(name), true);
    }
    onPromise(event, resolveImmediately = false) {
      if (resolveImmediately)
        return Promise.resolve();
      return new Promise((resolve) => this.one("solve", () => resolve()));
    }
    animate(rules, duration = 400, delay2 = 0, easing = "ease-in-out") {
      return transition(this, rules, duration, delay2, easing);
    }
    enter(effect = "fade", duration = 500, delay2 = 0) {
      return enter(this, effect, duration, delay2);
    }
    exit(effect = "fade", duration = 500, delay2 = 0, remove = false) {
      return exit(this, effect, duration, delay2, remove);
    }
    effect(className) {
      this.one("animationend", () => this.removeClass("effects-" + className));
      this.addClass("effects-" + className);
    }
    copy(recursive = true, withStyles = true, styleKeys) {
      const $copy = $(this._el.cloneNode(recursive));
      if (withStyles)
        $copy.copyInlineStyles(this, recursive, styleKeys);
      return $copy;
    }
    copyInlineStyles($source, recursive = true, styleKeys) {
      const style = window.getComputedStyle($source._el);
      for (const s of styleKeys || Array.from(style)) {
        this.css(s, style.getPropertyValue(s));
      }
      if (recursive) {
        const children = this.children;
        const sourceChildren = $source.children;
        for (let i = 0; i < children.length; ++i) {
          children[i].copyInlineStyles(sourceChildren[i], true, styleKeys);
        }
      }
    }
  };
  var HTMLBaseView = class extends BaseView {
    get offsetTop() {
      return this._el.offsetTop;
    }
    get offsetLeft() {
      return this._el.offsetLeft;
    }
    get offsetParent() {
      return $(this._el.offsetParent || void 0);
    }
    get width() {
      return this._el.offsetWidth;
    }
    get height() {
      return this._el.offsetHeight;
    }
    get innerWidth() {
      const left = parseFloat(this.css("padding-left"));
      const right = parseFloat(this.css("padding-right"));
      return this._el.clientWidth - left - right;
    }
    get innerHeight() {
      const bottom = parseFloat(this.css("padding-bottom"));
      const top = parseFloat(this.css("padding-top"));
      return this._el.clientHeight - bottom - top;
    }
    get outerWidth() {
      const left = parseFloat(this.css("margin-left"));
      const right = parseFloat(this.css("margin-right"));
      return this.width + left + right || 0;
    }
    get outerHeight() {
      const bottom = parseFloat(this.css("margin-bottom"));
      const top = parseFloat(this.css("margin-top"));
      return this.height + bottom + top || 0;
    }
    get positionTop() {
      let el = this._el;
      let offset = 0;
      while (el) {
        offset += el.offsetTop;
        el = el.offsetParent;
      }
      return offset;
    }
    get positionLeft() {
      let el = this._el;
      let offset = 0;
      while (el) {
        offset += el.offsetLeft;
        el = el.offsetParent;
      }
      return offset;
    }
    offset(parent) {
      if (parent._el === this._el.offsetParent) {
        const top = this.offsetTop + parent._el.clientTop;
        const left = this.offsetLeft + parent._el.clientLeft;
        const bottom = top + this.height;
        const right = left + this.width;
        return {top, left, bottom, right};
      } else {
        const parentBox = parent._el.getBoundingClientRect();
        const box = this._el.getBoundingClientRect();
        return {
          top: box.top - parentBox.top,
          left: box.left - parentBox.left,
          bottom: box.bottom - parentBox.top,
          right: box.right - parentBox.left
        };
      }
    }
  };
  var SVG_STYLES = [
    "font-family",
    "font-size",
    "font-style",
    "font-weight",
    "letter-spacing",
    "text-decoration",
    "color",
    "display",
    "visibility",
    "alignment-baseline",
    "baseline-shift",
    "text-anchor",
    "clip",
    "clip-path",
    "clip-rule",
    "mask",
    "opacity",
    "filter",
    "fill",
    "fill-rule",
    "marker",
    "marker-start",
    "marker-mid",
    "marker-end",
    "stroke",
    "stroke-dasharray",
    "stroke-dashoffset",
    "stroke-linecap",
    "stroke-linejoin",
    "stroke-width",
    "text-rendering",
    "transform",
    "dominant-baseline"
  ];
  var SVGBaseView = class extends BaseView {
    constructor() {
      super(...arguments);
      this.type = "svg";
    }
    get $ownerSVG() {
      return $(this._el.ownerSVGElement || void 0);
    }
    get width() {
      return this.bounds.width;
    }
    get height() {
      return this.bounds.height;
    }
    get positionLeft() {
      const svgLeft = this._el.getBBox().x + this._el.getCTM().e;
      return this.$ownerSVG.positionLeft + svgLeft;
    }
    get positionTop() {
      const svgTop = this._el.getBBox().y + this._el.getCTM().f;
      return this.$ownerSVG.positionTop + svgTop;
    }
    get inverseTransformMatrix() {
      const m = this._el.getScreenCTM().inverse();
      const matrix = [[m.a, m.c, m.e], [m.b, m.d, m.f]];
      if (Browser.isFirefox) {
        const transform = this.transformMatrix;
        matrix[0][2] -= transform[0][2];
        matrix[1][2] -= transform[1][2];
      }
      return matrix;
    }
    setTransform(posn, angle = 0, scale = 1) {
      const t1 = posn ? `translate(${roundTo(posn.x, 0.1)} ${roundTo(posn.y, 0.1)})` : "";
      const t2 = nearlyEquals(angle, 0) ? "" : `rotate(${angle * 180 / Math.PI})`;
      const t3 = nearlyEquals(scale, 1) ? "" : `scale(${scale})`;
      this.setAttr("transform", [t1, t2, t3].join(" "));
    }
    get strokeLength() {
      if (this._el instanceof SVGGeometryElement) {
        return this._el.getTotalLength();
      } else {
        const dim = this.bounds;
        return 2 * dim.height + 2 * dim.width;
      }
    }
    getPointAtLength(d) {
      if (this._el instanceof SVGGeometryElement) {
        const point = this._el.getPointAtLength(d);
        return new Point(point.x, point.y);
      } else {
        return new Point(0, 0);
      }
    }
    getPointAt(p) {
      return this.getPointAtLength(p * this.strokeLength);
    }
    get points() {
      return parsePath(this.attr("d"));
    }
    set points(p) {
      const d = p.length ? "M" + p.map((x) => x.x + "," + x.y).join("L") : "";
      this.setAttr("d", d);
    }
    addPoint(p) {
      const d = this.attr("d") + " L " + p.x + "," + p.y;
      this.setAttr("d", d);
    }
    get center() {
      const x = +this.attr(this.tagName === "TEXT" ? "x" : "cx");
      const y = +this.attr(this.tagName === "TEXT" ? "y" : "cy");
      return new Point(x, y);
    }
    setCenter(c) {
      this.setAttr(this.tagName === "TEXT" ? "x" : "cx", c.x);
      this.setAttr(this.tagName === "TEXT" ? "y" : "cy", c.y);
    }
    setLine(p, q) {
      this.setAttr("x1", p.x);
      this.setAttr("y1", p.y);
      this.setAttr("x2", q.x);
      this.setAttr("y2", q.y);
    }
    setRect(rect) {
      this.setAttr("x", rect.p.x);
      this.setAttr("y", rect.p.y);
      this.setAttr("width", rect.w);
      this.setAttr("height", rect.h);
    }
    draw(obj, options = {}) {
      if (!obj)
        return this.setAttr("d", "");
      const attributes = {
        mark: this.attr("mark"),
        arrows: this.attr("arrows"),
        size: +this.attr("size") || void 0,
        fill: this.hasClass("fill"),
        round: this.hasAttr("round")
      };
      this.setAttr("d", drawSVG(obj, applyDefaults(options, attributes)));
    }
  };
  var SVGParentView = class extends SVGBaseView {
    get viewBox() {
      return this._el.viewBox.baseVal || {width: 0, height: 0};
    }
    get $ownerSVG() {
      return this;
    }
    get positionLeft() {
      return parseInt(this.css("margin-left")) + this.parent.positionLeft;
    }
    get positionTop() {
      return parseInt(this.css("margin-top")) + this.parent.positionTop;
    }
    get svgWidth() {
      return this.viewBox.width || this.width;
    }
    get svgHeight() {
      return this.viewBox.height || this.height;
    }
    drawPath(obj, attributes = {}, options = {}) {
      const $el = $N("path", attributes, this);
      $el.draw(obj, options);
      return $el;
    }
    pngImage(width, height, viewBox) {
      return __awaiter(this, void 0, void 0, function* () {
        const $copy = this.copy(true, true, SVG_STYLES);
        if (!height)
          height = width || this.svgHeight;
        if (!width)
          width = this.svgWidth;
        $copy.setAttr("width", width);
        $copy.setAttr("height", height);
        $copy.setAttr("viewBox", viewBox || this.attr("viewBox") || `0 0 ${this.svgWidth} ${this.svgHeight}`);
        $copy.setAttr("xmlns", "http://www.w3.org/2000/svg");
        const $images = $copy.$$('image[href^="http"]');
        yield Promise.all($images.map(($i) => __awaiter(this, void 0, void 0, function* () {
          const img = yield loadImage($i.attr("href"));
          const $canvas2 = $N("canvas", {width: img.width, height: img.height});
          $canvas2.ctx.drawImage(img, 0, 0, img.width, img.height);
          const dataUri = yield $canvas2.pngImage;
          $i.setAttr("href", dataUri);
        })));
        const serialised = new XMLSerializer().serializeToString($copy._el);
        const url = "data:image/svg+xml;utf8," + encodeURIComponent(serialised);
        const $canvas = $N("canvas", {width, height});
        $canvas.ctx.fillStyle = $html.css("background-color") || "white";
        $canvas.ctx.fillRect(0, 0, width, height);
        const image = yield loadImage(url);
        $canvas.ctx.drawImage(image, 0, 0, width, height);
        return $canvas.pngImage;
      });
    }
    downloadImage(fileName, width, height, viewBox) {
      const windowRef = Browser.isIOS ? window.open("", "_blank") : void 0;
      this.pngImage(width, height, viewBox).then((href) => {
        if (windowRef)
          return windowRef.location.href = href;
        const $a = $N("a", {download: fileName, href, target: "_blank"});
        $a._el.dispatchEvent(new MouseEvent("click", {view: window, bubbles: false, cancelable: true}));
      });
    }
  };
  var WindowView = class extends HTMLBaseView {
    constructor() {
      super(...arguments);
      this.type = "window";
    }
    get width() {
      return window.innerWidth;
    }
    get height() {
      return window.innerHeight;
    }
    get innerWidth() {
      return window.innerWidth;
    }
    get innerHeight() {
      return window.innerHeight;
    }
    get outerWidth() {
      return window.outerWidth;
    }
    get outerHeight() {
      return window.outerHeight;
    }
    get scrollWidth() {
      return document.body.scrollWidth;
    }
    get scrollHeight() {
      return document.body.scrollHeight;
    }
    get scrollTop() {
      return window.pageYOffset;
    }
    set scrollTop(y) {
      document.body.scrollTop = document.documentElement.scrollTop = y;
      this.trigger("scroll", {top: y, left: this.scrollLeft});
    }
    get scrollLeft() {
      return window.pageXOffset;
    }
    set scrollLeft(x) {
      document.body.scrollLeft = document.documentElement.scrollLeft = x;
      this.trigger("scroll", {top: this.scrollTop, left: x});
    }
  };
  var FormView = class extends HTMLBaseView {
    constructor() {
      super(...arguments);
      this.type = "form";
    }
    get action() {
      return this._el.action;
    }
    get formData() {
      const data = {};
      for (const el of Array.from(this._el.elements)) {
        const id = el.name || el.id;
        if (id)
          data[id] = el.value;
      }
      return data;
    }
    get isValid() {
      return this._el.checkValidity();
    }
  };
  var InputView = class extends HTMLBaseView {
    constructor() {
      super(...arguments);
      this.type = "input";
    }
    get checked() {
      return this._el.checked || false;
    }
    set checked(value) {
      this._el.checked = value;
    }
    get value() {
      return this._el.value;
    }
    set value(v) {
      this._el.value = v;
    }
    bindVariable(model, name) {
      const isNumber = this._el.type === "number";
      const isCheckbox = this._el.type === "checkbox";
      if (name in model) {
        isCheckbox ? this.checked = model[name] : this.value = model[name];
      } else if (this.value) {
        isCheckbox ? model[name] = this.checked : model[name] = this.value;
      }
      if (isNumber) {
        const min = this.hasAttr("min") ? +this.attr("min") : -Infinity;
        const max = this.hasAttr("max") ? +this.attr("max") : Infinity;
        this.change((v) => model[name] = clamp(+v, min, max));
        this.on("blur", () => this.value = model[name]);
      } else if (isCheckbox) {
        this.on("change", () => model[name] = this.checked);
      } else {
        this.change((v) => model[name] = v);
      }
      model.watch(() => {
        isCheckbox ? this.checked = model[name] : this.value = model[name];
      });
    }
    setInputPattern(value) {
      if (isNaN(+value))
        return;
      const digitsOnly = value.match(/^[0-9]+$/);
      this.setAttr("inputmode", digitsOnly ? "numeric" : "decimal");
      if (digitsOnly)
        this.setAttr("pattern", "[0-9]*");
    }
    change(callback) {
      let value = this.value || "";
      this.on("change keyup input paste", () => {
        if (this.value === value)
          return;
        value = this.value.trim();
        callback(value);
      });
    }
    validate(callback) {
      this.change((value) => this.setValidity(callback(value)));
    }
    setValidity(str) {
      this._el.setCustomValidity(str);
    }
    get isValid() {
      return this._el.checkValidity();
    }
  };
  var CanvasView = class extends HTMLBaseView {
    constructor() {
      super(...arguments);
      this.type = "canvas";
    }
    getContext(c = "2d", options = {}) {
      return this._el.getContext(c, options);
    }
    get pngImage() {
      return this._el.toDataURL("image/png");
    }
    get canvasWidth() {
      return this._el.width;
    }
    get canvasHeight() {
      return this._el.height;
    }
    get ctx() {
      if (!this._ctx)
        this._ctx = this.getContext();
      return this._ctx;
    }
    draw(obj, options = {}) {
      this.ctx.save();
      drawCanvas(this.ctx, obj, options);
      this.ctx.restore();
    }
    clear() {
      this.ctx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);
    }
    fill(color) {
      this.ctx.save();
      this.ctx.fillStyle = color;
      this.ctx.fillRect(0, 0, this.canvasWidth, this.canvasHeight);
      this.ctx.restore();
    }
    clearCircle(center, radius) {
      this.ctx.save();
      this.ctx.globalCompositeOperation = "destination-out";
      this.ctx.beginPath();
      this.ctx.arc(center.x, center.y, radius, 0, 2 * Math.PI, false);
      this.ctx.fill();
      this.ctx.restore();
    }
    downloadImage(fileName) {
      const href = this.pngImage;
      const $a = $N("a", {download: fileName, href, target: "_blank"});
      $a._el.dispatchEvent(new MouseEvent("click", {view: window, bubbles: false, cancelable: true}));
    }
  };
  var MediaView = class extends HTMLBaseView {
    play() {
      return this._el.play() || Promise.resolve();
    }
    pause() {
      return this._el.pause();
    }
  };
  var SVG_TAGS = [
    "path",
    "rect",
    "circle",
    "ellipse",
    "polygon",
    "polyline",
    "g",
    "defs",
    "marker",
    "line",
    "text",
    "tspan",
    "pattern",
    "mask",
    "svg",
    "foreignObject",
    "image",
    "use"
  ];
  function $(query, context) {
    if (!query)
      return void 0;
    const c = context ? context._el : document.documentElement;
    const el = typeof query === "string" ? c.querySelector(query) : query;
    if (!el)
      return void 0;
    if (el._view)
      return el._view;
    const tagName = (el.tagName || "").toLowerCase();
    if (tagName === "svg") {
      return new SVGParentView(el);
    } else if (tagName === "canvas") {
      return new CanvasView(el);
    } else if (tagName === "form") {
      return new FormView(el);
    } else if (tagName === "input" || tagName === "select" || tagName === "textarea") {
      return new InputView(el);
    } else if (tagName === "video" || tagName === "audio") {
      return new MediaView(el);
    } else if (SVG_TAGS.includes(tagName)) {
      return new SVGBaseView(el);
    } else {
      return new HTMLBaseView(el);
    }
  }
  function $$(selector, context) {
    const c = context ? context._el : document.documentElement;
    const els = selector ? c.querySelectorAll(selector) : [];
    return Array.from(els, (el) => $(el));
  }
  function $N(tag, attributes = {}, parent) {
    const el = !SVG_TAGS.includes(tag) ? document.createElement(tag) : document.createElementNS("http://www.w3.org/2000/svg", tag);
    for (const [key, value] of Object.entries(attributes)) {
      if (value === void 0)
        continue;
      if (key === "id") {
        el.id = value;
      } else if (key === "html") {
        el.innerHTML = value;
      } else if (key === "text") {
        el.textContent = value;
      } else if (key === "path") {
        el.setAttribute("d", drawSVG(value));
      } else {
        el.setAttribute(key, value);
      }
    }
    const $el = $(el);
    if (parent)
      parent.append($el);
    return $el;
  }
  var $body = new WindowView(document.body);
  var $html = new WindowView(document.documentElement);
  var KEY_CODES = {
    backspace: 8,
    tab: 9,
    enter: 13,
    shift: 16,
    ctrl: 17,
    alt: 18,
    pause: 19,
    capslock: 20,
    escape: 27,
    space: 32,
    pageup: 33,
    pagedown: 34,
    end: 35,
    home: 36,
    left: 37,
    up: 38,
    right: 39,
    down: 40,
    insert: 45,
    delete: 46
  };
  var STORAGE_KEY = "_M";
  var UA = window.navigator.userAgent.toLowerCase();
  var KEY_NAMES = {};
  for (const [name, id] of Object.entries(KEY_CODES))
    KEY_NAMES[id] = name;
  var MOBILE_REGEX = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i;
  var IOS_REGEX = /iphone|ipad|ipod/i;
  var SAFARI_REGEX = /^((?!chrome|android).)*safari/i;
  var BrowserInstance = class {
    constructor() {
      var _a3, _b, _c;
      this.isMobile = MOBILE_REGEX.test(UA);
      this.isRetina = (window.devicePixelRatio || 1) > 1;
      this.isTouch = !!window.Touch || "ontouchstart" in window;
      this.isChrome = !!window.chrome;
      this.isFirefox = UA.indexOf("firefox") >= 0;
      this.isAndroid = UA.indexOf("android") >= 0;
      this.isIOS = IOS_REGEX.test(UA);
      this.isSafari = IOS_REGEX.test(UA) || SAFARI_REGEX.test(UA);
      this.loadQueue = [];
      this.loaded = false;
      this.width = window.innerWidth;
      this.height = window.innerHeight;
      this.resizeCallbacks = [];
      this.theme = {name: "light", isDark: false};
      this.themeChangedCallbacks = [];
      this.themeOverride = "";
      this.darkQuery = (_a3 = window.matchMedia) === null || _a3 === void 0 ? void 0 : _a3.call(window, "(prefers-color-scheme: dark)");
      window.onload = () => this.afterLoad();
      document.addEventListener("DOMContentLoaded", () => this.afterLoad());
      const applyResizeThrottled = throttle(() => this.applyResize());
      window.addEventListener("resize", applyResizeThrottled);
      try {
        (_b = this.darkQuery) === null || _b === void 0 ? void 0 : _b.addEventListener("change", () => this.applyThemeChange());
      } catch (_d) {
        (_c = this.darkQuery) === null || _c === void 0 ? void 0 : _c.addListener(() => this.applyThemeChange());
      }
      const initial = this.getCookie("theme");
      if (initial)
        this.setTheme(initial);
      try {
        this.localStorage = window.localStorage;
      } catch (_e) {
        console.warn("Unable to access Local Storage in this context.");
      }
    }
    afterLoad() {
      if (this.loaded)
        return;
      this.loaded = true;
      for (const fn of this.loadQueue)
        fn();
      setTimeout(() => this.resize());
    }
    ready(fn) {
      if (this.loaded) {
        fn();
      } else {
        this.loadQueue.push(fn);
      }
    }
    redraw() {
      document.body.offsetHeight;
    }
    applyResize() {
      const newWidth = window.innerWidth;
      const newHeight = window.innerHeight;
      if (this.width === newWidth && this.height === newHeight)
        return;
      this.width = newWidth;
      this.height = newHeight;
      for (const fn of this.resizeCallbacks)
        fn({width: this.width, height: this.height});
      $body.trigger("scroll", {top: $body.scrollTop});
    }
    onResize(fn) {
      fn({width: this.width, height: this.height});
      this.resizeCallbacks.push(fn);
    }
    offResize(fn) {
      const i = this.resizeCallbacks.indexOf(fn);
      if (i >= 0)
        this.resizeCallbacks.splice(i, 1);
    }
    resize() {
      this.applyResize();
    }
    applyThemeChange() {
      const name = this.theme.name;
      const isDark = name === "dark" || name === "auto" && this.darkQuery.matches;
      if (isDark === this.theme.isDark)
        return;
      this.theme.isDark = isDark;
      $html.setAttr("theme", this.themeOverride || (isDark ? "dark" : "light"));
      for (const c of this.themeChangedCallbacks)
        c(this.theme);
    }
    setTheme(name) {
      if (name === this.theme.name)
        return;
      this.theme.name = name;
      this.setCookie("theme", name);
      this.applyThemeChange();
    }
    onThemeChange(fn) {
      this.themeChangedCallbacks.push(fn);
    }
    getHash() {
      return window.location.hash.slice(1);
    }
    setHash(h) {
      const scroll = document.body.scrollTop;
      window.location.hash = h;
      document.body.scrollTop = scroll;
    }
    setURL(url, title = "") {
      window.history.replaceState({}, title, url);
      if (title)
        window.document.title = title;
    }
    getCookies() {
      const pairs = document.cookie.split(";");
      const result = {};
      for (let i = 0, n = pairs.length; i < n; ++i) {
        const pair = pairs[i].split("=");
        result[decodeURIComponent(pair[0]).trim()] = decodeURIComponent(pair[1]);
      }
      return result;
    }
    getCookie(name) {
      const v = document.cookie.match(new RegExp(`(^|;) ?${name}=([^;]*)(;|$)`));
      return v ? v[2] : void 0;
    }
    setCookie(name, value, maxAge = 60 * 60 * 24 * 365) {
      const domain = window.location.hostname.replace(/^[a-z]{2}\./, "");
      document.cookie = `${name}=${value};path=/;max-age=${maxAge};domain=${domain}`;
    }
    deleteCookie(name) {
      this.setCookie(name, "", -1);
    }
    setStorage(key, value) {
      var _a3, _b;
      const keys = (key || "").split(".");
      const storage = safeToJSON(((_a3 = this.localStorage) === null || _a3 === void 0 ? void 0 : _a3.getItem(STORAGE_KEY)) || void 0);
      let path = storage;
      for (let i = 0; i < keys.length - 1; ++i) {
        if (path[keys[i]] == void 0)
          path[keys[i]] = {};
        path = path[keys[i]];
      }
      path[keys[keys.length - 1]] = value;
      (_b = this.localStorage) === null || _b === void 0 ? void 0 : _b.setItem(STORAGE_KEY, JSON.stringify(storage));
    }
    getStorage(key) {
      var _a3;
      let path = safeToJSON(((_a3 = this.localStorage) === null || _a3 === void 0 ? void 0 : _a3.getItem(STORAGE_KEY)) || void 0);
      if (!key)
        return path;
      const keys = (key || "").split(".");
      const lastKey = keys.pop();
      for (const k of keys) {
        if (!(k in path))
          return;
        path = path[k];
      }
      return path[lastKey];
    }
    deleteStorage(key) {
      var _a3;
      if (key) {
        this.setStorage(key, void 0);
      } else {
        (_a3 = this.localStorage) === null || _a3 === void 0 ? void 0 : _a3.setItem(STORAGE_KEY, "");
      }
    }
    getActiveInput() {
      const active = document.activeElement;
      return active === document.body ? void 0 : $(active);
    }
    onKey(keys, fn, up = false) {
      const keyNames = words(keys);
      const event = up ? "keyup" : "keydown";
      document.addEventListener(event, (e) => {
        const key = KEY_NAMES[e.keyCode] || e.key;
        if (!keyNames.includes(key))
          return;
        const $active = this.getActiveInput();
        if ($active && $active.is("input, textarea, [contenteditable]"))
          return;
        if ($active && ["space", "enter", "tab"].includes(key) && $active.is("button, a, [tabindex]"))
          return;
        fn(e, key);
      });
    }
  };
  var Browser = window.BoostBrowser || new BrowserInstance();
  window.BoostBrowser = Browser;
  var IEUA = /\bTrident\/[567]\b|\bMSIE (?:9|10)\.0\b/;
  var webkitUA = /\bAppleWebKit\/(\d+)\b/;
  var EdgeUA = /\bEdge\/12\.(\d+)\b/;
  var polyfill = IEUA.test(navigator.userAgent) || +(navigator.userAgent.match(EdgeUA) || [])[1] < 10547 || +(navigator.userAgent.match(webkitUA) || [])[1] < 537;
  var requests = {};
  function replaceSvgImports() {
    if (!polyfill)
      return;
    const uses = Array.from(document.querySelectorAll("svg > use"));
    uses.forEach(function(use) {
      const src = use.getAttribute("xlink:href");
      const [url, id] = src.split("#");
      if (!url.length || !id)
        return;
      const svg = use.parentNode;
      svg.removeChild(use);
      if (!(url in requests))
        requests[url] = fetch(url).then((r) => r.text());
      const request = requests[url];
      request.then((response) => {
        const doc = document.implementation.createHTMLDocument("");
        doc.documentElement.innerHTML = response;
        const icon = doc.getElementById(id);
        const clone = icon.cloneNode(true);
        const fragment = document.createDocumentFragment();
        while (clone.childNodes.length)
          fragment.appendChild(clone.firstChild);
        svg.appendChild(fragment);
      });
    });
  }
  function bindAccessibilityEvents() {
    document.addEventListener("keydown", (e) => {
      if (e.keyCode === KEY_CODES.enter || e.keyCode === KEY_CODES.space) {
        const $active = Browser.getActiveInput();
        if ($active && $active.hasAttr("tabindex") && $active.tagName !== "TEXTAREA") {
          e.preventDefault();
          $active.trigger("pointerdown", e);
          $active.trigger("pointerstop", e);
          $body.trigger("pointerstop", e);
          $active.trigger("click", e);
        }
      }
    });
  }
  var isReady$1 = false;
  setTimeout(() => isReady$1 = true);
  var BOUNCE_IN = "cubic-bezier(0.175, 0.885, 0.32, 1.275)";
  var BOUNCE_OUT = "cubic-bezier(0.68, -0.275, 0.825, 0.115)";
  var ResolvedAnimation = {cancel: () => void 0, promise: Promise.resolve()};
  function animate(callback, duration) {
    if (duration === 0) {
      callback(1, 0, () => void 0);
      return ResolvedAnimation;
    }
    const startTime = Date.now();
    const deferred = defer();
    let lastTime = 0;
    let running = true;
    const cancel = () => {
      running = false;
      deferred.reject();
    };
    function getFrame() {
      if (running && (!duration || lastTime <= duration)) {
        window.requestAnimationFrame(getFrame);
      }
      const time = Date.now() - startTime;
      callback(duration ? Math.min(1, time / duration) : time, time - lastTime, cancel);
      if (duration && time >= duration)
        deferred.resolve();
      lastTime = time;
    }
    getFrame();
    return {cancel, promise: deferred.promise};
  }
  function easeIn(type, t = 0, s = 0) {
    switch (type) {
      case "quad":
        return Math.pow(t, 2);
      case "cubic":
        return Math.pow(t, 3);
      case "quart":
        return Math.pow(t, 4);
      case "quint":
        return Math.pow(t, 5);
      case "circ":
        return 1 - Math.sqrt(1 - Math.pow(t, 2));
      case "sine":
        return 1 - Math.cos(t * Math.PI / 2);
      case "exp":
        return t <= 0 ? 0 : Math.pow(2, 10 * (t - 1));
      case "back":
        if (!s)
          s = 1.70158;
        return t * t * ((s + 1) * t - s);
      case "elastic":
        if (!s)
          s = 0.3;
        return -Math.pow(2, 10 * (t - 1)) * Math.sin(((t - 1) * 2 / s - 0.5) * Math.PI);
      case "swing":
        return 0.5 - Math.cos(t * Math.PI) / 2;
      case "spring":
        return 1 - Math.cos(t * 4.5 * Math.PI) * Math.exp(-t * 6);
      case "bounce":
        if (t < 1 / 11)
          return 1 / 64 - 7.5625 * (0.5 / 11 - t) * (0.5 / 11 - t);
        if (t < 3 / 11)
          return 1 / 16 - 7.5625 * (2 / 11 - t) * (2 / 11 - t);
        if (t < 7 / 11)
          return 1 / 4 - 7.5625 * (5 / 11 - t) * (5 / 11 - t);
        return 1 - 7.5625 * (1 - t) * (1 - t);
      default:
        return t;
    }
  }
  function ease(type, t = 0, s = 0) {
    if (t === 0)
      return 0;
    if (t === 1)
      return 1;
    const [name, direction] = type.split("-");
    if (direction === "in")
      return easeIn(name, t, s);
    if (direction === "out")
      return 1 - easeIn(name, 1 - t, s);
    if (t <= 0.5)
      return easeIn(name, 2 * t, s) / 2;
    return 1 - easeIn(name, 2 * (1 - t), s) / 2;
  }
  function transition($el, properties, duration = 400, _delay = 0, easing = "ease-in-out") {
    if (!isReady$1) {
      Object.keys(properties).forEach((k) => {
        const p = properties[k];
        $el.css(k, Array.isArray(p) ? p[1] : p);
      });
      return ResolvedAnimation;
    }
    if (easing === "bounce-in")
      easing = BOUNCE_IN;
    if (easing === "bounce-out")
      easing = BOUNCE_OUT;
    let oldTransition = "";
    if (Browser.isSafari) {
      oldTransition = $el._el.style.transition;
      $el.css("transition", "none");
      Browser.redraw();
    }
    const currentAnimation = $el._data["animation"];
    if (currentAnimation)
      currentAnimation.cancel();
    const to = {};
    const from = {};
    const deferred = defer();
    const style = window.getComputedStyle($el._el);
    Object.keys(properties).forEach((k) => {
      const p = properties[k];
      const k1 = toCamelCase(k);
      from[k1] = Array.isArray(p) ? p[0] : style.getPropertyValue(k);
      to[k1] = Array.isArray(p) ? p[1] : p;
      if (_delay)
        $el.css(k, from[k1]);
    });
    const oldHeight = to.height;
    if (to.height === "auto") {
      to.height = total($el.children.map(($c) => $c.outerHeight)) + "px";
    }
    let player;
    let cancelled = false;
    delay(() => {
      if (cancelled)
        return;
      player = $el._el.animate([from, to], {duration, easing, fill: "forwards"});
      player.onfinish = () => {
        if ($el._el) {
          Object.keys(properties).forEach((k) => $el.css(k, k === "height" ? oldHeight : to[k]));
        }
        if (Browser.isSafari)
          $el.css("transition", oldTransition);
        deferred.resolve();
        player.cancel();
      };
    }, _delay);
    const animation = {
      cancel() {
        cancelled = true;
        if ($el._el)
          Object.keys(properties).forEach((k) => $el.css(k, $el.css(k)));
        if (player)
          player.cancel();
      },
      promise: deferred.promise
    };
    setTimeout(() => $el._data["animation"] = animation);
    return animation;
  }
  var CSS_MATRIX = /matrix\([0-9.\-\s]+,[0-9.\-\s]+,[0-9.\-\s]+,[0-9.\-\s]+,([0-9.\-\s]+),([0-9.\-\s]+)\)/;
  function enter($el, effect = "fade", duration = 500, _delay = 0) {
    $el.show();
    if (!isReady$1)
      return ResolvedAnimation;
    const opacity = +$el.css("opacity") || 1;
    if (effect === "fade") {
      return transition($el, {opacity: [0, opacity]}, duration, _delay);
    } else if (effect === "pop") {
      const transform = $el.transform.replace(/scale\([0-9.]*\)/, "").replace(CSS_MATRIX, "translate($1px,$2px)");
      transition($el, {opacity: [0, opacity]}, duration, _delay);
      return transition($el, {
        transform: [transform + " scale(0.5)", transform + " scale(1)"]
      }, duration, _delay, "bounce-in");
    } else if (effect === "descend") {
      const rules = {opacity: [0, 1], transform: ["translateY(-50%)", "none"]};
      return transition($el, rules, duration, _delay);
    } else if (effect.startsWith("draw")) {
      const l = $el.strokeLength;
      $el.css("stroke-dasharray", l + "px");
      if (!$el.css("opacity"))
        $el.css("opacity", 1);
      const end = effect === "draw-reverse" ? 2 * l + "px" : 0;
      const rules = {"stroke-dashoffset": [l + "px", end]};
      const animation = transition($el, rules, duration, _delay, "linear");
      animation.promise.then(() => $el.css("stroke-dasharray", ""));
      return animation;
    } else if (effect.startsWith("slide")) {
      const rules = {opacity: [0, opacity], transform: ["translateY(50px)", "none"]};
      if (effect.includes("down"))
        rules.transform[0] = "translateY(-50px)";
      if (effect.includes("right"))
        rules.transform[0] = "translateX(-50px)";
      if (effect.includes("left"))
        rules.transform[0] = "translateX(50px)";
      return transition($el, rules, duration, _delay);
    } else if (effect.startsWith("reveal")) {
      const rules = {opacity: [0, opacity], height: [0, "auto"]};
      if (effect.includes("left"))
        rules.transform = ["translateX(-50%)", "none"];
      if (effect.includes("right"))
        rules.transform = ["translateX(50%)", "none"];
      return transition($el, rules, duration, _delay);
    }
    return ResolvedAnimation;
  }
  function exit($el, effect = "fade", duration = 400, delay2 = 0, remove = false) {
    if (!$el._el)
      return ResolvedAnimation;
    if (!isReady$1) {
      $el.hide();
      return ResolvedAnimation;
    }
    if ($el.css("display") === "none")
      return ResolvedAnimation;
    let animation;
    if (effect === "fade") {
      animation = transition($el, {opacity: [1, 0]}, duration, delay2);
    } else if (effect === "pop") {
      const transform = $el.transform.replace(/scale\([0-9.]*\)/, "");
      transition($el, {opacity: [1, 0]}, duration, delay2);
      animation = transition($el, {
        transform: [transform + " scale(1)", transform + " scale(0.5)"]
      }, duration, delay2, "bounce-out");
    } else if (effect === "ascend") {
      const rules = {opacity: [1, 0], transform: ["none", "translateY(-50%)"]};
      animation = transition($el, rules, duration, delay2);
    } else if (effect.startsWith("draw")) {
      const l = $el.strokeLength;
      $el.css("stroke-dasharray", l);
      const start = effect === "draw-reverse" ? 2 * l + "px" : 0;
      const rules = {"stroke-dashoffset": [start, l + "px"]};
      animation = transition($el, rules, duration, delay2, "linear");
    } else if (effect.startsWith("slide")) {
      const rules = {opacity: 0, transform: "translateY(50px)"};
      if (effect.includes("up"))
        rules.transform = "translateY(-50px)";
      animation = transition($el, rules, duration, delay2);
    } else if (effect.startsWith("reveal")) {
      const rules = {opacity: 0, height: 0};
      if (effect.includes("left"))
        rules.transform = "translateX(-50%)";
      if (effect.includes("right"))
        rules.transform = "translateX(50%)";
      animation = transition($el, rules, duration, delay2);
    }
    animation.promise.then(() => remove ? $el.remove() : $el.hide());
    return animation;
  }
  var LOADING_STYLE = "position: fixed; top: 0; left: 0; width: 100%; height: 4px; background: #0f82f2; pointer-events: none; z-index: 9999; will-change: transform;";
  function getViewParams(url, view) {
    const match = view.regex.exec(url);
    if (match) {
      match.shift();
      const params = {};
      for (const [i, p] of view.params.entries())
        params[p] = match[i];
      return params;
    } else {
      return void 0;
    }
  }
  function getTemplate(view, params, url) {
    return __awaiter(this, void 0, void 0, function* () {
      if (view.template) {
        if (typeof view.template === "string")
          return view.template;
        return view.template(params);
      }
      const str = yield fetch(url + (url.indexOf("?") >= 0 ? "&xhr=1" : "?xhr=1"));
      return str.text();
    });
  }
  var isReady = document.readyState === "complete";
  window.addEventListener("load", () => setTimeout(() => isReady = true));
  if ("scrollRestoration" in window.history) {
    window.history.scrollRestoration = "manual";
  }
  var Router = class extends EventTarget {
    constructor() {
      super(...arguments);
      this.$viewport = $body;
      this.views = [];
      this.active = {path: "", hash: ""};
      this.preloaded = false;
      this.transition = false;
      this.noLoad = false;
      this.initialise = () => void 0;
    }
    setup(options = {}) {
      if (options.$viewport)
        this.$viewport = options.$viewport;
      if (options.initialise)
        this.initialise = options.initialise;
      if (options.preloaded)
        this.preloaded = options.preloaded;
      if (options.transition)
        this.transition = options.transition;
      if (options.noLoad)
        this.noLoad = options.noLoad;
      if (options.click) {
        $body.on("click", (e) => this.onLinkClick(e));
      }
      if (options.history) {
        window.addEventListener("popstate", (e) => __awaiter(this, void 0, void 0, function* () {
          var _a3;
          if (!isReady || !((_a3 = e.state) === null || _a3 === void 0 ? void 0 : _a3.path))
            return;
          const success = yield this.load(e.state.path, e.state.hash);
          if (!success)
            window.history.pushState(this.active, "", this.active.path + this.active.hash);
        }));
      }
    }
    view(url, {enter: enter2, exit: exit2, template} = {}) {
      const params = (url.match(/:\w+/g) || []).map((x) => x.substr(1));
      const regexStr = url.replace(/:\w+/g, "([\\w-]+)").replace("/", "\\/") + "\\/?";
      const searchStr = url.includes("?") ? "" : "(\\?.*)?";
      const regex = new RegExp("^" + regexStr + searchStr + "$", "i");
      const thisView = {regex, params, enter: enter2, exit: exit2, template};
      this.views.push(thisView);
      const current = window.location.pathname + window.location.search;
      const viewParams = getViewParams(current, thisView);
      if (!viewParams)
        return;
      this.active = {path: current, hash: window.location.hash};
      window.history.replaceState(this.active, "", this.active.path + this.active.hash);
      Browser.ready(() => {
        setTimeout(() => {
          if (this.preloaded) {
            this.initialise(this.$viewport, viewParams);
            if (thisView.enter)
              thisView.enter(this.$viewport, viewParams);
          } else {
            this.loadView(thisView, viewParams);
          }
        });
      });
    }
    paths(...urls) {
      for (const url of urls)
        this.view(url);
    }
    getView(path) {
      for (const view of this.views) {
        const params = getViewParams(path, view);
        if (params)
          return {view, params};
      }
    }
    load(path, hash) {
      return __awaiter(this, void 0, void 0, function* () {
        if (path === this.active.path && hash !== this.active.hash) {
          this.trigger("hashChange", hash.slice(1));
          this.trigger("change", path + hash);
          this.active = {path, hash};
          return true;
        }
        const go = this.getView(path);
        if (!go)
          return false;
        if (this.beforeChange && !(yield this.beforeChange()))
          return false;
        this.active = {path, hash};
        this.trigger("change", path + hash);
        if (window.ga)
          window.ga("send", "pageview", path + hash);
        if (this.noLoad) {
          if (go.view.enter)
            go.view.enter(this.$viewport, go.params);
        } else {
          this.loadView(go.view, go.params);
        }
        return true;
      });
    }
    loadView(view, params = {}) {
      return __awaiter(this, void 0, void 0, function* () {
        this.showLoadingBar();
        const path = this.active.path;
        const template = yield getTemplate(view, params, path);
        if (this.active.path !== path)
          return;
        yield this.$viewport.animate({opacity: 0}, 200).promise;
        this.$viewport.removeChildren();
        $body.scrollTop = 0;
        this.$viewport.html = template;
        Browser.resize();
        replaceSvgImports();
        this.$viewport.animate({opacity: 1}, 200);
        this.hideLoadingBar();
        const $title = this.$viewport.$("title");
        if ($title)
          document.title = $title.text;
        this.initialise(this.$viewport, params);
        if (view.enter)
          view.enter(this.$viewport, params);
        this.trigger("afterChange", {$viewport: this.$viewport});
      });
    }
    onLinkClick(e) {
      if (e.metaKey || e.ctrlKey || e.shiftKey)
        return;
      if (e.defaultPrevented)
        return;
      let el = e.target;
      while (el && el.nodeName !== "A")
        el = el.parentNode;
      if (!el || el.nodeName !== "A")
        return;
      const anchor = el;
      if (anchor.target)
        return;
      if (anchor.origin !== window.location.origin)
        return;
      if (anchor.hasAttribute("download") || anchor.getAttribute("rel") === "external")
        return;
      const link = anchor.getAttribute("href");
      if (link && link.indexOf("mailto:") > -1)
        return;
      if (this.getView(anchor.pathname + anchor.search)) {
        e.preventDefault();
        this.goTo(anchor.pathname + anchor.search, anchor.hash);
      }
    }
    goTo(path, hash = "") {
      return __awaiter(this, void 0, void 0, function* () {
        const current = this.active.path + this.active.hash;
        const success = yield this.load(path, hash);
        if (success && current !== this.active.path + this.active.hash) {
          window.history.pushState(this.active, "", path + hash);
        }
      });
    }
    replace(path, hash = "") {
      this.active = {path, hash};
      window.history.replaceState(this.active, "", path + hash);
    }
    back() {
      window.history.back();
    }
    forward() {
      window.history.forward();
    }
    showLoadingBar() {
      if (!this.$loadingBar)
        this.$loadingBar = $N("div", {style: LOADING_STYLE}, $body);
      this.$loadingBar.css({transform: "translateX(-100%)", opacity: 1});
      this.$loadingBar.show();
      this.animation = animate((p) => {
        this.$loadingBar.css("transform", `translateX(-${10 + 90 * Math.exp(-4 * p)}%)`);
      }, 3e3);
    }
    hideLoadingBar() {
      var _a3, _b, _c;
      return __awaiter(this, void 0, void 0, function* () {
        (_a3 = this.animation) === null || _a3 === void 0 ? void 0 : _a3.cancel();
        yield (_b = this.$loadingBar) === null || _b === void 0 ? void 0 : _b.animate({transform: "none", opacity: 0}).promise;
        (_c = this.$loadingBar) === null || _c === void 0 ? void 0 : _c.hide();
      });
    }
  };
  var RouterInstance = new Router();
  function applyTemplate(el, template) {
    const children = Array.from(el.childNodes);
    el.innerHTML = template;
    const slots = {};
    for (const s of Array.from(el.querySelectorAll("slot"))) {
      slots[s.getAttribute("name") || ""] = s;
    }
    for (const child of children) {
      const name = child.getAttribute ? child.getAttribute("slot") || "" : "";
      const slot = slots[name] || slots[""];
      if (slot)
        slot.parentNode.insertBefore(child, slot);
    }
    for (const slot of Object.values(slots))
      slot.parentNode.removeChild(slot);
  }
  function customElementChildren(el) {
    const result = [];
    for (const c of Array.from(el.children)) {
      if (c.tagName.startsWith("X-")) {
        result.push(c);
      } else {
        result.push(...customElementChildren(c));
      }
    }
    return result;
  }
  var customElementOptions = new Map();
  var CustomHTMLElement = class extends HTMLElement {
    constructor() {
      super(...arguments);
      this.wasConnected = false;
      this.isReady = false;
    }
    connectedCallback() {
      return __awaiter(this, void 0, void 0, function* () {
        if (this.wasConnected) {
          this._view.trigger("connected");
          return;
        }
        this.wasConnected = true;
        this.isReady = false;
        this._view.created();
        const options = customElementOptions.get(this._view.tagName) || {};
        if (options.template)
          applyTemplate(this, options.template);
        const promises = customElementChildren(this).filter((c) => !c.isReady).map((c) => new Promise((res) => c.addEventListener("ready", res)));
        yield Promise.all(promises);
        this._view.ready();
        this.dispatchEvent(new CustomEvent("ready"));
        this.isReady = true;
      });
    }
    disconnectedCallback() {
      this._view.trigger("disconnected");
    }
  };
  var CustomElementView = class extends HTMLBaseView {
    created() {
    }
    ready() {
    }
  };
  function register(tagName, options = {}) {
    return function(ElementClass) {
      class Constructor extends CustomHTMLElement {
        constructor() {
          super();
          this._view = new ElementClass(this);
        }
      }
      customElementOptions.set(tagName.toUpperCase(), options);
      window.customElements.define(tagName, Constructor);
    };
  }

  // node_modules/@mathigon/studio/frontend/components/modal/modal.ts
  var $modalBackground = $N("div", {class: "modal-background"}, $body);
  var backgroundAnimation;
  var $openModal = void 0;
  var lastFocusElement = void 0;
  function tryClose() {
    if ($openModal && $openModal.canClose)
      $openModal.close();
  }
  $modalBackground.on("click", tryClose);
  Browser.onKey("escape", tryClose);
  RouterInstance.on("change", tryClose);
  $modalBackground.on("scrollwheel touchmove", (e) => {
    e.preventDefault();
    e.stopPropagation();
  });
  Browser.onKey("space up down pagedown pageup", (e) => {
    if ($openModal) {
      e.preventDefault();
      e.stopPropagation();
    }
  });
  var Modal = class extends CustomElementView {
    constructor() {
      super(...arguments);
      this.isOpen = false;
      this.canClose = true;
    }
    ready() {
      this.canClose = !this.hasAttr("no-close");
      this.$iframe = this.$("iframe[data-src]");
      this.$video = this.$("video");
      const $buttons = $$(`[data-modal=${this.id}]`);
      for (const $b of $buttons)
        $b.on("click", () => this.open());
      RouterInstance.on("afterChange", ({$viewport}) => {
        const $buttons2 = $viewport.$$(`[data-modal=${this.id}]`);
        for (const $b of $buttons2)
          $b.on("click", () => this.open());
      });
      if (this.hasClass("open") && !$openModal)
        this.open(true);
      if (this.$("input"))
        this.addClass("interactive");
      const $close = this.$(".close");
      if ($close)
        $close.on("click", () => this.close());
      for (const $btn of this.$$(".btn"))
        $btn.on("click", () => this.trigger("btn-click", $btn));
    }
    open(noAnimation = false) {
      if (this.isOpen)
        return;
      $modalBackground.setClass("light", this.hasClass("light"));
      if ($openModal) {
        $openModal.close(true);
      } else if (noAnimation) {
        $modalBackground.show();
      } else if ($modalBackground.css("display") === "block") {
        backgroundAnimation == null ? void 0 : backgroundAnimation.cancel();
      } else {
        $modalBackground.enter("fade", 250);
      }
      this.isOpen = true;
      $openModal = this;
      if (this.$iframe)
        this.$iframe.setAttr("src", this.$iframe.data.src);
      if (this.$video)
        this.$video.play();
      if (noAnimation) {
        this.show();
      } else {
        this.enter("pop", 250).promise.then(() => this.css("transform", ""));
      }
      this.setAttr("role", "dialog");
      this.trigger("open");
      lastFocusElement = document.activeElement;
      const $focus = this.$('input, a, button, textarea, [tabindex="0"]');
      if ($focus)
        $focus.focus();
    }
    close(keepBg = false, noEvent = false) {
      if (!this.isOpen)
        return;
      this.isOpen = false;
      this.removeAttr("role");
      $openModal = void 0;
      if (this.$iframe)
        this.$iframe.setAttr("src", "");
      if (this.$video)
        this.$video.pause();
      if (!keepBg)
        backgroundAnimation = $modalBackground.exit("fade", 250);
      this.exit("pop", 250).promise.then(() => this.css("transform", ""));
      if (!noEvent)
        this.trigger("close");
      if (lastFocusElement)
        lastFocusElement.focus();
    }
    static confirm(selector) {
      return __async(this, null, function* () {
        var _a3;
        const modal = $(selector);
        if (!modal)
          return "";
        modal.open();
        const el = yield new Promise((r) => modal.one("close btn-click", r));
        modal.close();
        return ((_a3 = el == null ? void 0 : el.data) == null ? void 0 : _a3.prompt) || "";
      });
    }
  };
  Modal = __decorate([
    register("x-modal")
  ], Modal);

  // node_modules/@mathigon/studio/frontend/components/select/select.ts
  var Select = class extends CustomElementView {
    constructor() {
      super(...arguments);
      this.$options = {};
    }
    ready() {
      const $items = this.children;
      this.$active = this.$(".active") || $items[0];
      this.$active.addClass("active");
      for (const [i, $i] of $items.entries()) {
        if (!isOneOf($i.tagName, "A", "BUTTON") && !$i.hasAttr("tabindex"))
          $i.setAttr("tabindex", 0);
        $i.on("click", () => this.makeActive($i));
        this.$options[$i.attr("value") || i] = $i;
      }
      this.trigger("change", this.$active);
    }
    makeActive($el) {
      if ($el === this.$active)
        return;
      this.$active.removeClass("active");
      this.$active = $el;
      $el.addClass("active");
      this.trigger("change", $el);
    }
    bindVariable(model, name) {
      model[name] = this.$active.attr("value");
      this.on("change", ($el) => model[name] = $el.attr("value"));
      model.watch(() => {
        const $el = this.$options[model[name]];
        if ($el)
          this.makeActive($el);
      });
    }
  };
  Select = __decorate([
    register("x-select")
  ], Select);

  // node_modules/@mathigon/studio/frontend/components/popup/popup.ts
  var Popup = class extends CustomElementView {
    constructor() {
      super(...arguments);
      this.isOpen = false;
    }
    ready() {
      this.animation = this.attr("animation") || "pop";
      this.$bubble = this.$(".popup-body");
      this.$bubble.hide();
      const $target = this.$(".popup-target");
      $target.on("click", () => this.toggle());
      this.on("clickOutside", () => this.close());
      for (const $a of this.$bubble.$$("a"))
        $a.on("click", () => this.close());
      Browser.onKey("escape", () => this.close());
    }
    toggle() {
      if (this.isOpen) {
        this.close();
      } else {
        this.open();
      }
    }
    open() {
      if (this.isOpen)
        return;
      this.isOpen = true;
      this.addClass("active");
      this.$bubble.enter(this.animation, 150);
      this.$bubble.setAttr("role", "dialog");
      this.$bubble.focus();
    }
    close() {
      if (!this.isOpen)
        return;
      this.isOpen = false;
      this.removeClass("active");
      this.$bubble.exit(this.animation, 150);
      this.$bubble.removeAttr("role");
    }
  };
  Popup = __decorate([
    register("x-popup")
  ], Popup);

  // node_modules/@mathigon/studio/frontend/components/alert/alert.ts
  var $alerts = new Map();
  var $openAlert;
  var $alertParent = $N("div", {class: "snackbar"}, $body);
  var Alert = class extends CustomElementView {
    ready() {
      var _a3;
      $alertParent.append(this);
      $alerts.set(this.attr("key"), this);
      (_a3 = this.$("button")) == null ? void 0 : _a3.on("click", () => this.close());
    }
    open(duration = 2e3) {
      return __async(this, null, function* () {
        if ($openAlert === this)
          return;
        if ($openAlert)
          yield $openAlert.close();
        $openAlert = this;
        yield this.enter("pop", 300).promise;
        this.setAttr("role", "alert");
        if (duration)
          setTimeout(() => this.close(), duration);
      });
    }
    close() {
      return __async(this, null, function* () {
        if ($openAlert !== this)
          return;
        $openAlert = void 0;
        this.removeAttr("role");
        yield this.exit("pop", 300).promise;
      });
    }
  };
  Alert = __decorate([
    register("x-alert")
  ], Alert);

  // node_modules/@mathigon/studio/frontend/components/icon/icon.ts
  var IconView = class extends CustomElementView {
    ready() {
      if (this.children.length)
        return;
      const size = +this.attr("size") || 24;
      this.css({width: size + "px", height: size + "px"});
      const $svg = $N("svg", {viewBox: "0 0 24 24"}, this);
      $svg.css({width: size + "px", height: size + "px"});
      const $use = $N("use", {}, $svg);
      this.onAttr("name", (n) => $use.setAttr("href", `/icons.1452bb03.svg#${n}`));
    }
  };
  IconView = __decorate([
    register("x-icon")
  ], IconView);

  // node_modules/@mathigon/studio/frontend/components/progress/progress.ts
  var PADDING = 12;
  function getProgress(r) {
    return `M${r},${r / 2}a${r / 2},${r / 2},0,0,1,0,${r}A${r / 2},${r / 2},0,0,1,${r},${r / 2}`;
  }
  function getCheck(r) {
    return `M ${r},0 C ${r / 2},0,0,${r / 2},0,${r}  s ${r / 2},${r},${r},${r} s ${r}-${r / 2},${r}-${r}     S ${r * 1.5},0,${r},0 z M ${r * 44.6 / 50},${r * 76.1 / 50} L ${r * 19.2 / 50},${r * 48.8 / 50} l ${r * 4 / 50}-${r * 4.2 / 50}     l ${r * 19.8 / 50},${r * 11.9 / 50} l ${r * 34.2 / 50}-${r * 32.6 / 50} l ${r * 3.5 / 50},${r * 3.5 / 50} L ${r * 44.6 / 50},${r * 76.1 / 50} z`;
  }
  var Progress = class extends CustomElementView {
    constructor() {
      super(...arguments);
      this.completed = false;
    }
    ready() {
      this.r = +this.attr("r") || 10;
      this.r1 = this.r + PADDING;
      this.$svg = $N("svg", {width: 2 * this.r1, height: 2 * this.r1}, this);
      this.$progress = $N("path", {
        class: "pie",
        d: getProgress(this.r),
        "stroke-width": this.r
      }, this.$svg);
      this.onAttr("p", (p) => this.setProgress(+p, false));
    }
    setProgress(p, animation = true) {
      if (p > 0.99)
        return this.complete(animation);
      const c = Math.PI * this.r;
      this.$progress.css("stroke", p ? "currentColor" : "none");
      this.$progress.css("stroke-dasharray", `${p * c} ${c}`);
    }
    complete(animation = true) {
      if (this.completed)
        return;
      this.completed = true;
      this.$progress.css("stroke", "none");
      this.$progress.css("fill", "currentColor");
      this.$progress.setAttr("d", getCheck(this.r));
      if (!animation)
        return;
      const transform = `translate(${this.r1} ${this.r1})`;
      const $g = $N("g", {transform}, this.$svg);
      const $burst = tabulate(() => $N("line", {}, $g), 18);
      animate((p) => {
        const r1 = this.r + PADDING * ease("quint-out", p);
        const r2 = this.r + PADDING * p;
        for (let i = 0; i < 18; ++i) {
          const c = Math.cos(Math.PI * 2 * i / 18);
          const s = Math.sin(Math.PI * 2 * i / 18);
          $burst[i].setLine({x: c * r1, y: s * r1}, {x: c * r2, y: s * r2});
        }
      }, 800).promise.then(() => $g.remove());
    }
  };
  Progress = __decorate([
    register("x-progress")
  ], Progress);

  // node_modules/autotrack/lib/constants.js
  var VERSION = "2.4.1";
  var DEV_ID = "i5iSjo";
  var VERSION_PARAM = "_av";
  var USAGE_PARAM = "_au";
  var NULL_DIMENSION = "(not set)";

  // node_modules/autotrack/lib/method-chain.js
  var instances = [];
  var MethodChain = class {
    static add(context, methodName, methodOverride) {
      getOrCreateMethodChain(context, methodName).add(methodOverride);
    }
    static remove(context, methodName, methodOverride) {
      getOrCreateMethodChain(context, methodName).remove(methodOverride);
    }
    constructor(context, methodName) {
      this.context = context;
      this.methodName = methodName;
      this.isTask = /Task$/.test(methodName);
      this.originalMethodReference = this.isTask ? context.get(methodName) : context[methodName];
      this.methodChain = [];
      this.boundMethodChain = [];
      this.wrappedMethod = (...args) => {
        const lastBoundMethod = this.boundMethodChain[this.boundMethodChain.length - 1];
        return lastBoundMethod(...args);
      };
      if (this.isTask) {
        context.set(methodName, this.wrappedMethod);
      } else {
        context[methodName] = this.wrappedMethod;
      }
    }
    add(overrideMethod) {
      this.methodChain.push(overrideMethod);
      this.rebindMethodChain();
    }
    remove(overrideMethod) {
      const index = this.methodChain.indexOf(overrideMethod);
      if (index > -1) {
        this.methodChain.splice(index, 1);
        if (this.methodChain.length > 0) {
          this.rebindMethodChain();
        } else {
          this.destroy();
        }
      }
    }
    rebindMethodChain() {
      this.boundMethodChain = [];
      for (let method, i = 0; method = this.methodChain[i]; i++) {
        const previousMethod = this.boundMethodChain[i - 1] || this.originalMethodReference.bind(this.context);
        this.boundMethodChain.push(method(previousMethod));
      }
    }
    destroy() {
      const index = instances.indexOf(this);
      if (index > -1) {
        instances.splice(index, 1);
        if (this.isTask) {
          this.context.set(this.methodName, this.originalMethodReference);
        } else {
          this.context[this.methodName] = this.originalMethodReference;
        }
      }
    }
  };
  var method_chain_default = MethodChain;
  function getOrCreateMethodChain(context, methodName) {
    let methodChain = instances.filter((h) => h.context == context && h.methodName == methodName)[0];
    if (!methodChain) {
      methodChain = new MethodChain(context, methodName);
      instances.push(methodChain);
    }
    return methodChain;
  }

  // node_modules/dom-utils/lib/matches.js
  var proto = window.Element.prototype;
  var nativeMatches = proto.matches || proto.matchesSelector || proto.webkitMatchesSelector || proto.mozMatchesSelector || proto.msMatchesSelector || proto.oMatchesSelector;

  // node_modules/dom-utils/lib/parse-url.js
  var HTTP_PORT = "80";
  var HTTPS_PORT = "443";
  var DEFAULT_PORT = RegExp(":(" + HTTP_PORT + "|" + HTTPS_PORT + ")$");
  var a = document.createElement("a");

  // node_modules/autotrack/lib/utilities.js
  function createFieldsObj(defaultFields, userFields, tracker = void 0, hitFilter = void 0, target = void 0, event = void 0) {
    if (typeof hitFilter == "function") {
      const originalBuildHitTask = tracker.get("buildHitTask");
      return {
        buildHitTask: (model) => {
          model.set(defaultFields, null, true);
          model.set(userFields, null, true);
          hitFilter(model, target, event);
          originalBuildHitTask(model);
        }
      };
    } else {
      return assign({}, defaultFields, userFields);
    }
  }
  var queueMap = {};
  function deferUntilPluginsLoaded(tracker, fn) {
    const trackingId = tracker.get("trackingId");
    const ref = queueMap[trackingId] = queueMap[trackingId] || {};
    const processQueue = () => {
      clearTimeout(ref.timeout);
      if (ref.send) {
        method_chain_default.remove(tracker, "send", ref.send);
      }
      delete queueMap[trackingId];
      ref.queue.forEach((fn2) => fn2());
    };
    clearTimeout(ref.timeout);
    ref.timeout = setTimeout(processQueue, 0);
    ref.queue = ref.queue || [];
    ref.queue.push(fn);
    if (!ref.send) {
      ref.send = (originalMethod) => {
        return (...args) => {
          processQueue();
          originalMethod(...args);
        };
      };
      method_chain_default.add(tracker, "send", ref.send);
    }
  }
  var assign = Object.assign || function(target, ...sources) {
    for (let i = 0, len = sources.length; i < len; i++) {
      const source = Object(sources[i]);
      for (let key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  function capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
  function isObject(value) {
    return typeof value == "object" && value !== null;
  }
  function now() {
    return +new Date();
  }
  var uuid = function b(a2) {
    return a2 ? (a2 ^ Math.random() * 16 >> a2 / 4).toString(16) : ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, b);
  };

  // node_modules/autotrack/lib/provide.js
  function provide(pluginName, pluginConstructor) {
    const gaAlias = window.GoogleAnalyticsObject || "ga";
    window[gaAlias] = window[gaAlias] || function(...args) {
      (window[gaAlias].q = window[gaAlias].q || []).push(args);
    };
    window.gaDevIds = window.gaDevIds || [];
    if (window.gaDevIds.indexOf(DEV_ID) < 0) {
      window.gaDevIds.push(DEV_ID);
    }
    window[gaAlias]("provide", pluginName, pluginConstructor);
    window.gaplugins = window.gaplugins || {};
    window.gaplugins[capitalize(pluginName)] = pluginConstructor;
  }

  // node_modules/autotrack/lib/event-emitter.js
  var EventEmitter = class {
    constructor() {
      this.registry_ = {};
    }
    on(event, fn) {
      this.getRegistry_(event).push(fn);
    }
    off(event = void 0, fn = void 0) {
      if (event && fn) {
        const eventRegistry = this.getRegistry_(event);
        const handlerIndex = eventRegistry.indexOf(fn);
        if (handlerIndex > -1) {
          eventRegistry.splice(handlerIndex, 1);
        }
      } else {
        this.registry_ = {};
      }
    }
    emit(event, ...args) {
      this.getRegistry_(event).forEach((fn) => fn(...args));
    }
    getEventCount() {
      let eventCount = 0;
      Object.keys(this.registry_).forEach((event) => {
        eventCount += this.getRegistry_(event).length;
      });
      return eventCount;
    }
    getRegistry_(event) {
      return this.registry_[event] = this.registry_[event] || [];
    }
  };
  var event_emitter_default = EventEmitter;

  // node_modules/autotrack/lib/store.js
  var AUTOTRACK_PREFIX = "autotrack";
  var instances2 = {};
  var isListening = false;
  var browserSupportsLocalStorage;
  var Store = class extends event_emitter_default {
    static getOrCreate(trackingId, namespace, defaults) {
      const key = [AUTOTRACK_PREFIX, trackingId, namespace].join(":");
      if (!instances2[key]) {
        instances2[key] = new Store(key, defaults);
        if (!isListening)
          initStorageListener();
      }
      return instances2[key];
    }
    static isSupported_() {
      if (browserSupportsLocalStorage != null) {
        return browserSupportsLocalStorage;
      }
      try {
        window.localStorage.setItem(AUTOTRACK_PREFIX, AUTOTRACK_PREFIX);
        window.localStorage.removeItem(AUTOTRACK_PREFIX);
        browserSupportsLocalStorage = true;
      } catch (err) {
        browserSupportsLocalStorage = false;
      }
      return browserSupportsLocalStorage;
    }
    static get_(key) {
      return window.localStorage.getItem(key);
    }
    static set_(key, value) {
      window.localStorage.setItem(key, value);
    }
    static clear_(key) {
      window.localStorage.removeItem(key);
    }
    constructor(key, defaults = {}) {
      super();
      this.key_ = key;
      this.defaults_ = defaults;
      this.cache_ = null;
    }
    get() {
      if (this.cache_) {
        return this.cache_;
      } else {
        if (Store.isSupported_()) {
          try {
            this.cache_ = parse(Store.get_(this.key_));
          } catch (err) {
          }
        }
        return this.cache_ = assign({}, this.defaults_, this.cache_);
      }
    }
    set(newData) {
      this.cache_ = assign({}, this.defaults_, this.cache_, newData);
      if (Store.isSupported_()) {
        try {
          Store.set_(this.key_, JSON.stringify(this.cache_));
        } catch (err) {
        }
      }
    }
    clear() {
      this.cache_ = {};
      if (Store.isSupported_()) {
        try {
          Store.clear_(this.key_);
        } catch (err) {
        }
      }
    }
    destroy() {
      delete instances2[this.key_];
      if (!Object.keys(instances2).length) {
        removeStorageListener();
      }
    }
  };
  var store_default = Store;
  function initStorageListener() {
    window.addEventListener("storage", storageListener);
    isListening = true;
  }
  function removeStorageListener() {
    window.removeEventListener("storage", storageListener);
    isListening = false;
  }
  function storageListener(event) {
    const store = instances2[event.key];
    if (store) {
      const oldData = assign({}, store.defaults_, parse(event.oldValue));
      const newData = assign({}, store.defaults_, parse(event.newValue));
      store.cache_ = newData;
      store.emit("externalSet", newData, oldData);
    }
  }
  function parse(source) {
    let data = {};
    if (source) {
      try {
        data = JSON.parse(source);
      } catch (err) {
      }
    }
    return data;
  }

  // node_modules/autotrack/lib/session.js
  var SECONDS = 1e3;
  var MINUTES = 60 * SECONDS;
  var instances3 = {};
  var Session = class {
    static getOrCreate(tracker, timeout, timeZone) {
      const trackingId = tracker.get("trackingId");
      if (instances3[trackingId]) {
        return instances3[trackingId];
      } else {
        return instances3[trackingId] = new Session(tracker, timeout, timeZone);
      }
    }
    constructor(tracker, timeout, timeZone) {
      this.tracker = tracker;
      this.timeout = timeout || Session.DEFAULT_TIMEOUT;
      this.timeZone = timeZone;
      this.sendHitTaskOverride = this.sendHitTaskOverride.bind(this);
      method_chain_default.add(tracker, "sendHitTask", this.sendHitTaskOverride);
      try {
        this.dateTimeFormatter = new Intl.DateTimeFormat("en-US", {timeZone: this.timeZone});
      } catch (err) {
      }
      const defaultProps = {
        hitTime: 0,
        isExpired: false
      };
      this.store = store_default.getOrCreate(tracker.get("trackingId"), "session", defaultProps);
      if (!this.store.get().id) {
        this.store.set({id: uuid()});
      }
    }
    getId() {
      return this.store.get().id;
    }
    isExpired(id = this.getId()) {
      if (id != this.getId())
        return true;
      const sessionData = this.store.get();
      if (sessionData.isExpired)
        return true;
      const oldHitTime = sessionData.hitTime;
      if (oldHitTime) {
        const currentDate = new Date();
        const oldHitDate = new Date(oldHitTime);
        if (currentDate - oldHitDate > this.timeout * MINUTES || this.datesAreDifferentInTimezone(currentDate, oldHitDate)) {
          return true;
        }
      }
      return false;
    }
    datesAreDifferentInTimezone(d1, d2) {
      if (!this.dateTimeFormatter) {
        return false;
      } else {
        return this.dateTimeFormatter.format(d1) != this.dateTimeFormatter.format(d2);
      }
    }
    sendHitTaskOverride(originalMethod) {
      return (model) => {
        originalMethod(model);
        const sessionControl = model.get("sessionControl");
        const sessionWillStart = sessionControl == "start" || this.isExpired();
        const sessionWillEnd = sessionControl == "end";
        const sessionData = this.store.get();
        sessionData.hitTime = now();
        if (sessionWillStart) {
          sessionData.isExpired = false;
          sessionData.id = uuid();
        }
        if (sessionWillEnd) {
          sessionData.isExpired = true;
        }
        this.store.set(sessionData);
      };
    }
    destroy() {
      method_chain_default.remove(this.tracker, "sendHitTask", this.sendHitTaskOverride);
      this.store.destroy();
      delete instances3[this.tracker.get("trackingId")];
    }
  };
  var session_default = Session;
  Session.DEFAULT_TIMEOUT = 30;

  // node_modules/autotrack/lib/usage.js
  var plugins = {
    CLEAN_URL_TRACKER: 1,
    EVENT_TRACKER: 2,
    IMPRESSION_TRACKER: 3,
    MEDIA_QUERY_TRACKER: 4,
    OUTBOUND_FORM_TRACKER: 5,
    OUTBOUND_LINK_TRACKER: 6,
    PAGE_VISIBILITY_TRACKER: 7,
    SOCIAL_WIDGET_TRACKER: 8,
    URL_CHANGE_TRACKER: 9,
    MAX_SCROLL_TRACKER: 10
  };
  var PLUGIN_COUNT = Object.keys(plugins).length;
  function trackUsage(tracker, plugin) {
    trackVersion(tracker);
    trackPlugin(tracker, plugin);
  }
  function convertHexToBin(hex) {
    return parseInt(hex || "0", 16).toString(2);
  }
  function convertBinToHex(bin) {
    return parseInt(bin || "0", 2).toString(16);
  }
  function padZeros(str, len) {
    if (str.length < len) {
      let toAdd = len - str.length;
      while (toAdd) {
        str = "0" + str;
        toAdd--;
      }
    }
    return str;
  }
  function flipBitOn(str, index) {
    return str.substr(0, index) + 1 + str.substr(index + 1);
  }
  function trackPlugin(tracker, pluginIndex) {
    const usageHex = tracker.get("&" + USAGE_PARAM);
    let usageBin = padZeros(convertHexToBin(usageHex), PLUGIN_COUNT);
    usageBin = flipBitOn(usageBin, PLUGIN_COUNT - pluginIndex);
    tracker.set("&" + USAGE_PARAM, convertBinToHex(usageBin));
  }
  function trackVersion(tracker) {
    tracker.set("&" + VERSION_PARAM, VERSION);
  }

  // node_modules/autotrack/lib/plugins/page-visibility-tracker.js
  var HIDDEN = "hidden";
  var VISIBLE = "visible";
  var PAGE_ID = uuid();
  var SECONDS2 = 1e3;
  var PageVisibilityTracker = class {
    constructor(tracker, opts) {
      trackUsage(tracker, plugins.PAGE_VISIBILITY_TRACKER);
      if (!document.visibilityState)
        return;
      const defaultOpts = {
        sessionTimeout: session_default.DEFAULT_TIMEOUT,
        visibleThreshold: 5 * SECONDS2,
        sendInitialPageview: false,
        fieldsObj: {}
      };
      this.opts = assign(defaultOpts, opts);
      this.tracker = tracker;
      this.lastPageState = document.visibilityState;
      this.visibleThresholdTimeout_ = null;
      this.isInitialPageviewSent_ = false;
      this.trackerSetOverride = this.trackerSetOverride.bind(this);
      this.handleChange = this.handleChange.bind(this);
      this.handleWindowUnload = this.handleWindowUnload.bind(this);
      this.handleExternalStoreSet = this.handleExternalStoreSet.bind(this);
      this.store = store_default.getOrCreate(tracker.get("trackingId"), "plugins/page-visibility-tracker");
      this.store.on("externalSet", this.handleExternalStoreSet);
      this.session = session_default.getOrCreate(tracker, this.opts.sessionTimeout, this.opts.timeZone);
      method_chain_default.add(tracker, "set", this.trackerSetOverride);
      window.addEventListener("unload", this.handleWindowUnload);
      document.addEventListener("visibilitychange", this.handleChange);
      deferUntilPluginsLoaded(this.tracker, () => {
        if (document.visibilityState == VISIBLE) {
          if (this.opts.sendInitialPageview) {
            this.sendPageview({isPageLoad: true});
            this.isInitialPageviewSent_ = true;
          }
          this.store.set({
            time: now(),
            state: VISIBLE,
            pageId: PAGE_ID,
            sessionId: this.session.getId()
          });
        } else {
          if (this.opts.sendInitialPageview && this.opts.pageLoadsMetricIndex) {
            this.sendPageLoad();
          }
        }
      });
    }
    handleChange() {
      if (!(document.visibilityState == VISIBLE || document.visibilityState == HIDDEN)) {
        return;
      }
      const lastStoredChange = this.getAndValidateChangeData();
      const change = {
        time: now(),
        state: document.visibilityState,
        pageId: PAGE_ID,
        sessionId: this.session.getId()
      };
      if (document.visibilityState == VISIBLE && this.opts.sendInitialPageview && !this.isInitialPageviewSent_) {
        this.sendPageview();
        this.isInitialPageviewSent_ = true;
      }
      if (document.visibilityState == HIDDEN && this.visibleThresholdTimeout_) {
        clearTimeout(this.visibleThresholdTimeout_);
      }
      if (this.session.isExpired(lastStoredChange.sessionId)) {
        this.store.clear();
        if (this.lastPageState == HIDDEN && document.visibilityState == VISIBLE) {
          clearTimeout(this.visibleThresholdTimeout_);
          this.visibleThresholdTimeout_ = setTimeout(() => {
            this.store.set(change);
            this.sendPageview({hitTime: change.time});
          }, this.opts.visibleThreshold);
        }
      } else {
        if (lastStoredChange.pageId == PAGE_ID && lastStoredChange.state == VISIBLE) {
          this.sendPageVisibilityEvent(lastStoredChange);
        }
        this.store.set(change);
      }
      this.lastPageState = document.visibilityState;
    }
    getAndValidateChangeData() {
      const lastStoredChange = this.store.get();
      if (this.lastPageState == VISIBLE && lastStoredChange.state == HIDDEN && lastStoredChange.pageId != PAGE_ID) {
        lastStoredChange.state = VISIBLE;
        lastStoredChange.pageId = PAGE_ID;
        this.store.set(lastStoredChange);
      }
      return lastStoredChange;
    }
    sendPageVisibilityEvent(lastStoredChange, {hitTime} = {}) {
      const delta = this.getTimeSinceLastStoredChange(lastStoredChange, {hitTime});
      if (delta && delta >= this.opts.visibleThreshold) {
        const deltaInSeconds = Math.round(delta / SECONDS2);
        const defaultFields = {
          transport: "beacon",
          nonInteraction: true,
          eventCategory: "Page Visibility",
          eventAction: "track",
          eventValue: deltaInSeconds,
          eventLabel: NULL_DIMENSION
        };
        if (hitTime) {
          defaultFields.queueTime = now() - hitTime;
        }
        if (this.opts.visibleMetricIndex) {
          defaultFields["metric" + this.opts.visibleMetricIndex] = deltaInSeconds;
        }
        this.tracker.send("event", createFieldsObj(defaultFields, this.opts.fieldsObj, this.tracker, this.opts.hitFilter));
      }
    }
    sendPageLoad() {
      const defaultFields = {
        transport: "beacon",
        eventCategory: "Page Visibility",
        eventAction: "page load",
        eventLabel: NULL_DIMENSION,
        ["metric" + this.opts.pageLoadsMetricIndex]: 1,
        nonInteraction: true
      };
      this.tracker.send("event", createFieldsObj(defaultFields, this.opts.fieldsObj, this.tracker, this.opts.hitFilter));
    }
    sendPageview({hitTime, isPageLoad} = {}) {
      const defaultFields = {transport: "beacon"};
      if (hitTime) {
        defaultFields.queueTime = now() - hitTime;
      }
      if (isPageLoad && this.opts.pageLoadsMetricIndex) {
        defaultFields["metric" + this.opts.pageLoadsMetricIndex] = 1;
      }
      this.tracker.send("pageview", createFieldsObj(defaultFields, this.opts.fieldsObj, this.tracker, this.opts.hitFilter));
    }
    trackerSetOverride(originalMethod) {
      return (field, value) => {
        const fields = isObject(field) ? field : {[field]: value};
        if (fields.page && fields.page !== this.tracker.get("page")) {
          if (this.lastPageState == VISIBLE) {
            this.handleChange();
          }
        }
        originalMethod(field, value);
      };
    }
    getTimeSinceLastStoredChange(lastStoredChange, {hitTime} = {}) {
      return lastStoredChange.time ? (hitTime || now()) - lastStoredChange.time : 0;
    }
    handleExternalStoreSet(newData, oldData) {
      if (newData.time == oldData.time)
        return;
      if (oldData.pageId == PAGE_ID && oldData.state == VISIBLE && !this.session.isExpired(oldData.sessionId)) {
        this.sendPageVisibilityEvent(oldData, {hitTime: newData.time});
      }
    }
    handleWindowUnload() {
      if (this.lastPageState != HIDDEN) {
        this.handleChange();
      }
    }
    remove() {
      this.store.destroy();
      this.session.destroy();
      method_chain_default.remove(this.tracker, "set", this.trackerSetOverride);
      window.removeEventListener("unload", this.handleWindowUnload);
      document.removeEventListener("visibilitychange", this.handleChange);
    }
  };
  provide("pageVisibilityTracker", PageVisibilityTracker);

  // node_modules/@mathigon/studio/frontend/main.ts
  bindAccessibilityEvents();
  $html.addClass((Browser.isMobile ? "is" : "not") + "-mobile");
  if (Browser.isSafari)
    $html.addClass("is-safari");
  setTimeout(() => $html.addClass("ready"));
  window.addEventListener("keydown", (e) => {
    if (e.keyCode === 9)
      $html.addClass("is-tabbing");
  });
  window.addEventListener("mousedown", () => {
    $html.removeClass("is-tabbing");
  });
  var $cookies = $(".cookie-warning");
  if ($cookies) {
    $("#yes-to-cookies").on("click", function() {
      $cookies.exit("pop", 300);
      Browser.setCookie("cookie_consent", 1);
    });
  }
  var _a;
  (_a = navigator.serviceWorker) == null ? void 0 : _a.register("/service_worker.js", {scope: "/"}).catch(() => console.warn("Unable to register Service Worker."));
  window.addEventListener("beforeinstallprompt", (e) => {
    e.prompt();
  });
  var _a2;
  (_a2 = $("#skip-nav")) == null ? void 0 : _a2.on("click", () => {
    var _a3;
    const $main = $("article") || $(".panel.active") || $(".body") || $body;
    (_a3 = $main.$("input, button, a, textarea, [contenteditable], [tabindex]")) == null ? void 0 : _a3.focus();
  });
  var $popup = $("nav x-popup");
  if ($popup) {
    const $buttons = $popup.$$(".popup-body a, .popup-body button");
    for (const $b of $buttons)
      $b.on("click", () => $popup.close());
  }
  var $languageLinks = $$("#language .locale-link");
  RouterInstance.on("change", (path) => {
    for (const $l of $languageLinks)
      $l.setAttr("href", $l.data.host + path);
  });
  var $darkMode = $("#dark-mode");
  if ($darkMode) {
    $darkMode.checked = Browser.theme.isDark;
    $darkMode.on("change", () => Browser.setTheme($darkMode.checked ? "dark" : "light"));
  }
  var SEARCH_CACHE = {};
  var $search = $("#search");
  var $input = $search == null ? void 0 : $search.$(".form-field input");
  var $results = $search == null ? void 0 : $search.$(".search-body");
  SEARCH_CACHE[""] = ($results == null ? void 0 : $results.html) || "";
  function cleanSearchInput(str) {
    str = str.trim().replace(/\s+/, " ").toLowerCase().slice(0, 50);
    return str === "pi" || str.length >= 3 ? str : "";
  }
  function loadSearchResults(str) {
    return __async(this, null, function* () {
      str = encodeURIComponent(cleanSearchInput(str));
      if (str in SEARCH_CACHE)
        return SEARCH_CACHE[str];
      const response = yield fetch(`/api/search?q=${str}`);
      if (!response.ok)
        return SEARCH_CACHE[str] = "";
      return SEARCH_CACHE[str] = yield response.text();
    });
  }
  var lastCount = 0;
  var visibleCount = 0;
  function triggerSearch(str) {
    return __async(this, null, function* () {
      const i = lastCount += 1;
      const results = yield loadSearchResults(str);
      if (i <= visibleCount)
        return;
      visibleCount = i;
      $results.html = results;
    });
  }
  $input == null ? void 0 : $input.change((str) => {
    Browser.setCookie("search", str, 60 * 60 * 24);
    setTimeout(() => {
      if ($input.value === str)
        triggerSearch(str);
    }, 300);
  });
  if ($input == null ? void 0 : $input.value) {
    $search.one("open", () => triggerSearch($input.value));
  }
})();